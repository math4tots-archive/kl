"""
From powershell:
$PSDefaultParameterValues['Out-File:Encoding'] = 'utf8'
python .\klc.py > main.c

From linux subsystem for windows:
gcc -std=c89 -Werror -Wpedantic -Wall -Wno-unused-function -Wno-unused-variable main.c && \
cp main.{c,cc} && \
g++ -std=c++98 -Werror -Wpedantic -Wall -Wno-unused-function -Wno-unused-variable main.cc && \
./a.out
"""
from typing import NamedTuple, Tuple, List, Union, Optional, Callable, Iterable
import abc
import re
import typing
import contextlib
import sys
import argparse


SYMBOLS = [
    ';',
    '.', ',', '!', '@', '^', '&', '+', '-', '/', '%', '*', '.', '=', '==', '<',
    '>', '<=', '>=', '(', ')', '{', '}', '[', ']',
]

KEYWORDS = {
    'is', 'not', 'null', 'true', 'false', 'new',
    'extern',
    'class', 'trait',
    'if', 'else', 'while', 'break', 'continue', 'return',
}

PRIMITIVE_TYPES = {
    'void',
    'bool',
    'int',
    'double',
    'function',
    'type',
}


CPRELUDE = r"""/* Autogenerated by the KL Compiler */
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define KLC_TAG_BOOL 0
#define KLC_TAG_INT 1
#define KLC_TAG_DOUBLE 2
#define KLC_TAG_FUNCTION 3
#define KLC_TAG_TYPE 4
#define KLC_TAG_OBJECT 5

typedef char KLC_bool;
typedef long KLC_int;
typedef struct KLC_header KLC_header;
typedef struct KLC_methodinfo KLC_methodinfo;
typedef struct KLC_methodlist KLC_methodlist;
typedef struct KLC_typeinfo KLC_typeinfo;
typedef struct KLC_var KLC_var;
typedef KLC_var (*KLC_fp)(int, KLC_var*); /* untyped function pointer */
typedef struct KLC_functioninfo KLC_functioninfo;
typedef KLC_functioninfo* KLC_function;

struct KLC_header {
  KLC_typeinfo* type;
  size_t refcnt;
  KLC_header* next;
};

struct KLC_methodinfo {
  const char* const name;
  const KLC_fp body;
};

struct KLC_methodlist {
  const size_t size;
  const KLC_methodinfo* const methods;
};

struct KLC_functioninfo {
  const char* const name;
  const KLC_fp body;
};

struct KLC_typeinfo {
  const char* const name;
  void (*const deleter)(KLC_header*, KLC_header**);
  const KLC_methodlist* const methods;
};

struct KLC_var {
  int tag;
  union {
    KLC_header* obj;
    KLC_int i;
    double d;
    KLC_function f;
    KLC_typeinfo* t;
  } u;
};

void KLC_errorf(const char* fmt, ...) {
  int* i = NULL;
  va_list args;
  va_start(args, fmt);
  vfprintf(stderr, fmt, args);
  va_end(args);
  printf("%d\n", *i);
}

void KLC_retain(KLC_header *obj) {
  if (obj) {
    obj->refcnt++;
  }
}

void KLC_retain_var(KLC_var v) {
  if (v.tag == KLC_TAG_OBJECT) {
    KLC_retain(v.u.obj);
  }
}

void KLC_partial_release(KLC_header* obj, KLC_header** delete_queue) {
  if (obj) {
    if (obj->refcnt) {
      obj->refcnt--;
    } else {
      obj->next = *delete_queue;
      *delete_queue = obj;
    }
  }
}

void KLC_partial_release_var(KLC_var v, KLC_header** delete_queue) {
  if (v.tag == KLC_TAG_OBJECT) {
    KLC_partial_release(v.u.obj, delete_queue);
  }
}

void KLC_release(KLC_header *obj) {
  KLC_header* delete_queue = NULL;
  KLC_partial_release(obj, &delete_queue);
  while (delete_queue) {
    obj = delete_queue;
    delete_queue = delete_queue->next;
    obj->type->deleter(obj, &delete_queue);
    free(obj);
  }
}

void KLC_release_var(KLC_var v) {
  if (v.tag == KLC_TAG_OBJECT) {
    KLC_release(v.u.obj);
  }
}

extern KLC_typeinfo KLC_typenull;
extern KLC_typeinfo KLC_typeint;
extern KLC_typeinfo KLC_typedouble;
extern KLC_typeinfo KLC_typefunction;
extern KLC_typeinfo KLC_typetype;

KLC_typeinfo* KLCNtype(KLC_var v) {
  switch (v.tag) {
    case KLC_TAG_INT:
      return &KLC_typeint;
    case KLC_TAG_DOUBLE:
      return &KLC_typedouble;
    case KLC_TAG_FUNCTION:
      return &KLC_typefunction;
    case KLC_TAG_TYPE:
      return &KLC_typetype;
    case KLC_TAG_OBJECT:
      return v.u.obj ? v.u.obj->type : &KLC_typenull;
  }
  KLC_errorf("Unrecognized type tag %d\n", v.tag);
  return NULL;
}

KLC_var KLC_bool_to_var(KLC_bool b) {
  KLC_var ret;
  ret.tag = KLC_TAG_BOOL;
  ret.u.i = b;
  return ret;
}

KLC_var KLC_int_to_var(KLC_int i) {
  KLC_var ret;
  ret.tag = KLC_TAG_INT;
  ret.u.i = i;
  return ret;
}

KLC_var KLC_double_to_var(double d) {
  KLC_var ret;
  ret.tag = KLC_TAG_DOUBLE;
  ret.u.d = d;
  return ret;
}

KLC_var KLC_function_to_var(KLC_function f) {
  KLC_var ret;
  ret.tag = KLC_TAG_FUNCTION;
  ret.u.f = f;
  return ret;
}

KLC_var KLC_type_to_var(KLC_typeinfo* t) {
  KLC_var ret;
  ret.tag = KLC_TAG_TYPE;
  ret.u.t = t;
  return ret;
}

KLC_var KLC_object_to_var(KLC_header* obj) {
  KLC_var ret;
  ret.tag = KLC_TAG_OBJECT;
  ret.u.obj = obj;
  return ret;
}

KLC_bool KLC_var_to_bool(KLC_var v) {
  /* TODO: Better error message */
  if (v.tag != KLC_TAG_BOOL) {
    KLC_errorf("var_to_bool: expected bool (tag %d) but got tag %d\n",
               KLC_TAG_BOOL, v.tag);
  }
  return v.u.i ? 1 : 0;
}

KLC_int KLC_var_to_int(KLC_var v) {
  /* TODO: Better error message */
  if (v.tag != KLC_TAG_INT) {
    KLC_errorf("var_to_int: expected int (tag %d) but got tag %d\n",
               KLC_TAG_INT, v.tag);
  }
  return v.u.i;
}

KLC_int KLC_var_to_double(KLC_var v) {
  /* TODO: Better error message */
  if (v.tag != KLC_TAG_DOUBLE) {
    KLC_errorf("var_to_double: expected double (tag %d) but got tag %d\n",
               KLC_TAG_DOUBLE, v.tag);
  }
  return v.u.d;
}

KLC_header* KLC_var_to_object(KLC_var v, KLC_typeinfo* ti) {
  /* TODO: Better error message */
  KLC_header* ret;
  if (v.tag != KLC_TAG_OBJECT) {
    KLC_errorf("var_to_object: not an object\n");
  }
  if (ti != v.u.obj->type) {
    KLC_errorf("var_to_object: not the right object type\n");
  }
  return v.u.obj;
}

KLC_var KLC_var_call(KLC_var f, int argc, KLC_var* argv) {
  /* TODO: Better error message */
  KLC_var result;

  if (f.tag != KLC_TAG_FUNCTION) {
    KLC_errorf("Not a function\n");
  }

  result = f.u.f->body(argc, argv);

  return result;
}

KLC_var KLC_mcall(const char* name, int argc, KLC_var* argv) {
  if (argc == 0) {
    KLC_errorf("mcall requires at least 1 arg");
  }
  {
    KLC_typeinfo* type = KLCNtype(argv[0]);
    const KLC_methodlist* mlist = type->methods;
    size_t len = mlist->size;
    const KLC_methodinfo* mbuf = mlist->methods;
    const KLC_methodinfo* m = NULL;
    size_t i;
    /* TODO: Faster method dispatch mechanism */
    if (len) {
      int cmp = strcmp(name, mbuf[0].name);
      if (cmp == 0) {
        m = mbuf;
      } else if (cmp > 0) {
        size_t lower = 0;
        size_t upper = len;
        while (lower + 1 < upper) {
          size_t mid = (lower + upper) / 2;
          cmp = strcmp(name, mbuf[mid].name);
          if (cmp == 0) {
            m = mbuf + mid;
            break;
          } else if (cmp < 0) {
            upper = mid;
          } else {
            lower = mid;
          }
        }
      }
    }
    if (!m) {
      KLC_errorf("No such method '%s' for type '%s'", name, type->name);
    }
    return m->body(argc, argv);
  }
}

KLC_int KLCNint_mAdd(KLC_int a, KLC_int b) {
  return a + b;
}

KLC_int KLCNint_mSub(KLC_int a, KLC_int b) {
  return a - b;
}

KLC_bool KLCNint_mEq(KLC_int a, KLC_int b) {
  return a == b;
}

void KLC_init_header(KLC_header* header, KLC_typeinfo* type) {
  header->type = type;
  header->refcnt = 0;
  header->next = NULL;
}

typedef struct KLCNString KLCNString;
struct KLCNString {
  /* TODO: Also keep a UTF32 representation for random access */
  KLC_header header;
  size_t bytesize; /* number of actual bytes in buffer (utf-8 representation) */
  size_t nchars;   /* number of unicode code points */
  char* buffer;
  char* utf32;
    /* In C89, there's no way to get an integer type that guarantees
     * 32-bits. As such, I want to error on side of correctness and
     * use chars instead for measuring out the uttf-32 representation.
     */
  int is_ascii;
};

void KLC_deleteString(KLC_header* robj, KLC_header** dq) {
  KLCNString *obj = (KLCNString*) robj;
  free(obj->buffer);
}

extern KLC_typeinfo KLC_typeString;

int KLC_check_ascii(const char* str) {
  while (*str) {
    if (((unsigned) *str) >= 128) {
      return 0;
    }
    str++;
  }
  return 1;
}

KLCNString* KLC_mkstr_with_buffer(size_t bytesize, char* str, int is_ascii) {
  KLCNString* obj = (KLCNString*) malloc(sizeof(KLCNString));
  if (!is_ascii) {
    KLC_errorf("Non-ascii strings not yet supported");
  }
  KLC_init_header(&obj->header, &KLC_typeString);
  obj->bytesize = bytesize;
  obj->nchars = bytesize; /* only true when is_ascii */
  obj->buffer = str;
  obj->utf32 = NULL;
  obj->is_ascii = is_ascii;
  return obj;
}

KLCNString* KLC_mkstr(const char *str) {
  size_t len = strlen(str);
  char* buffer = (char*) malloc(sizeof(char) * (len + 1));
  strcpy(buffer, str);
  return KLC_mkstr_with_buffer(len, buffer, KLC_check_ascii(buffer));
}

KLC_int KLCNString_mbytesize(KLCNString* s) {
  /* TODO: This may be lossy. Figure this out */
  return (KLC_int) s->bytesize;
}

KLC_int KLCNString_msize(KLCNString* s) {
  /* TODO: This may be lossy. Figure this out */
  return (KLC_int) s->nchars;
}

KLCNString* KLCNString_mAdd(KLCNString* a, KLCNString* b) {
  size_t bytesize = a->bytesize + b->bytesize;
  char* buffer = (char*) malloc(sizeof(char) * (bytesize + 1));
  return KLC_mkstr_with_buffer(bytesize, buffer, a->is_ascii && b->is_ascii);
}

void KLCNputs(KLCNString *s) {
  printf("%s\n", s->buffer);
}

KLCNString* KLCNstr(KLC_var v) {
  switch (v.tag) {
    case KLC_TAG_BOOL:
      return KLC_mkstr(v.u.i ? "true" : "false");
    case KLC_TAG_INT: {
      char buffer[50];
      sprintf(buffer, "%ld", v.u.i);
      return KLC_mkstr(buffer);
    }
    case KLC_TAG_DOUBLE: {
      char buffer[50];
      sprintf(buffer, "%f", v.u.d);
      return KLC_mkstr(buffer);
    }
    case KLC_TAG_FUNCTION: {
      size_t namelen = strlen(v.u.f->name);
      size_t len = namelen + 50;
      char* buffer = (char*) malloc(sizeof(char) * len);
      KLCNString* ret;
      strcpy(buffer, "<function ");
      strcpy(buffer + strlen(buffer), v.u.f->name);
      strcpy(buffer + strlen(buffer), ">");
      ret = KLC_mkstr(buffer);
      free(buffer);
      return ret;
    }
    case KLC_TAG_TYPE: {
      size_t namelen = strlen(v.u.t->name);
      size_t len = namelen + 50;
      char* buffer = (char*) malloc(sizeof(char) * len);
      KLCNString* ret;
      strcpy(buffer, "<type ");
      strcpy(buffer + strlen(buffer), v.u.t->name);
      strcpy(buffer + strlen(buffer), ">");
      ret = KLC_mkstr(buffer);
      free(buffer);
      return ret;
    }
    case KLC_TAG_OBJECT:
      if (v.u.obj->type == &KLC_typeString) {
        KLC_retain(v.u.obj);
        return (KLCNString*) v.u.obj;
      } else {
        size_t namelen = strlen(v.u.obj->type->name);
        size_t len = namelen + 30;
        char* buffer = (char*) malloc(sizeof(char) * len);
        KLCNString* ret;
        buffer[0] = '<';
        strcpy(buffer + 1, v.u.obj->type->name);
        strcpy(buffer + 1 + namelen, " instance>");
        ret = KLC_mkstr(buffer);
        free(buffer);
        return ret;
      }
    default:
      KLC_errorf("str: Unrecognized var tag: %d", v.tag);
      return NULL;
  }
}

void KLCNmain();

static const KLC_var KLC_null = {
  KLC_TAG_OBJECT,
  { NULL }
};

int main() {
  KLCNmain();
  return 0;
}

"""

_primitive_method_names = {
    'null': [],
    'bool': [],
    'int': ['Add', 'Sub', 'Eq'],
    'double': [],
    'function': [],
    'type': [],
}


class Source(NamedTuple):
    filename: str
    data: str


class Token:
    __slots__ = ['type', 'value', 'source', 'i']

    def __init__(self,
                 type: str,
                 value: object = None,
                 source: Optional[Source] = None,
                 i: Optional[int] = None) -> None:
        self.type = type
        self.value = value
        self.source = source
        self.i = i

    def _key(self) -> Tuple[str, object]:
        return self.type, self.value

    def __eq__(self, other: object) -> bool:
        return isinstance(other, Token) and self._key() == other._key()

    def __hash__(self) -> int:
        return hash(self._key())

    def __repr__(self) -> str:
        return f'Token({repr(self.type)}, {repr(self.value)})'

    @property
    def lineno(self) -> int:
        assert self.source is not None
        assert self.i is not None
        return self.source.data.count('\n', 0, self.i) + 1

    @property
    def colno(self) -> int:
        assert self.source is not None
        assert self.i is not None
        return self.i - self.source.data.rfind('\n', 0, self.i)

    @property
    def line(self) -> str:
        assert self.source is not None
        assert self.i is not None
        s = self.source.data
        a = s.rfind('\n', 0, self.i) + 1
        b = s.find('\n', self.i)
        if b == -1:
            b = len(s)
        return s[a:b]

    @property
    def info(self) -> str:
        line = self.line
        colno = self.colno
        lineno = self.lineno
        spaces = ' ' * (colno - 1)
        return f'on line {lineno}\n{line}\n{spaces}*\n'


class Error(Exception):
    def __init__(self, tokens: Iterable[Token], message: str) -> None:
        super().__init__(''.join(token.info for token in tokens) + message)


class Pattern(abc.ABC):
    @abc.abstractmethod
    def match(self, source: Source, i: int) -> Optional[Tuple[Token, int]]:
        pass


class RegexPattern(Pattern):
    def __init__(
            self,
            regex: Union[typing.Pattern[str], str],
            *,
            type: Optional[str] = None,
            type_callback: Callable[[str], str] = lambda value: value,
            value_callback: Callable[[str], object] = lambda x: x) -> None:
        if isinstance(regex, str):
            regex = re.compile(regex)

        if type is not None:
            type_ = str(type)  # for mypy
            type_callback = lambda _: type_

        self.regex = regex
        self.type_callback = type_callback
        self.value_callback = value_callback

    def match(self, source: Source, i: int) -> Optional[Tuple[Token, int]]:
        m = self.regex.match(source.data, i)
        if m is None:
            return None

        raw_value = m.group()
        type_ = self.type_callback(raw_value)
        value = self.value_callback(raw_value)
        return Token(type_, value, source, i), m.end()


def _make_lexer():
    whitespace_and_comment_pattern = RegexPattern(r'(?:\s|//.*\n)+')

    class Lexer:
        def __init__(
                self,
                patterns: List[Pattern],
                *,
                ignore_pattern: Pattern,
                filter: Callable[[Token], Optional[Token]] = lambda token: token
        ) -> None:
            self.patterns = patterns
            self.ignore_pattern = ignore_pattern
            self.filter = filter

        def lex(self, source: Union[Source, str]) -> List[Token]:
            if isinstance(source, str):
                source = Source('<string>', source)

            ignore_pattern = self.ignore_pattern
            i = 0
            s = source.data
            tokens = []

            while True:
                while True:
                    match = ignore_pattern.match(source, i)
                    if match is None:
                        break
                    _, i = match

                if i >= len(s):
                    break

                for pattern in self.patterns:
                    match = pattern.match(source, i)
                    if match is not None:
                        unfiltered_token, i = match
                        token = self.filter(unfiltered_token)
                        if token is not None:
                            tokens.append(token)
                        break
                else:
                    token = Token('ERR', None, source, i)
                    raise Error([token], 'Unrecognized token')

            tokens.append(Token('EOF', None, source, i))
            return tokens

    class MatchingBracesSkipSpacesFilter:
        """A lexer filter for ignoring newlines that appear inside parentheses
        or square brackets.
        """

        def __init__(self) -> None:
            self.stack: List[Token] = []

        def should_skip_newlines(self) -> bool:
            return bool(self.stack and self.stack[-1].type != '{')

        def __call__(self, token: Token) -> Optional[Token]:
            if token.type in ('{', '[', '('):
                self.stack.append(token)

            if token.type in ('}', ']', ')'):
                self.stack.pop()

            if token.type == '\n' and self.should_skip_newlines():
                return None

            return token

    def make_symbols_pattern(symbols: Iterable[str]) -> Pattern:
        return RegexPattern('|'.join(map(re.escape, reversed(sorted(symbols)))))

    def make_keywords_pattern(keywords: Iterable[str]) -> Pattern:
        return RegexPattern('|'.join(r'\b' + kw + r'\b' for kw in keywords))

    name_pattern = RegexPattern(
        '\w+', type='NAME', value_callback=lambda value: value)

    def string_pattern_value_callback(value: str) -> str:
        return str(eval(value))  # type: ignore

    string_pattern_regex = '|'.join([
        r'(?:r)?"""(?:(?:\\.)|(?!""").)*"""',
        r"(?:r)?'''(?:(?:\\.)|(?!''').)*'''",
        r'(?:r)?"(?:(?:\\.)|(?!").)*"',
        r"(?:r)?'(?:(?:\\.)|(?!').)*'",
    ])

    string_pattern = RegexPattern(
        string_pattern_regex,
        type='STRING',
        value_callback=string_pattern_value_callback)

    float_pattern = RegexPattern(
        r'\d+\.\d*|\.\d+', type='FLOAT', value_callback=eval)  # type: ignore
    int_pattern = RegexPattern(
        r'\d+', type='INT', value_callback=eval)  # type: ignore

    def make_simple_lexer(*, keywords: Iterable[str], symbols: Iterable[str]):
        keywords_pattern = make_keywords_pattern(keywords)
        symbols_pattern = make_symbols_pattern(symbols)
        return Lexer(
            [
                string_pattern,
                keywords_pattern,
                float_pattern,
                int_pattern,
                name_pattern,
                symbols_pattern,
            ],
            ignore_pattern=whitespace_and_comment_pattern)

    return make_simple_lexer(keywords=KEYWORDS, symbols=SYMBOLS)


_lexer = _make_lexer()


def lex(source):
    return _lexer.lex(source)


class FractalStringBuilder(object):
    def __init__(self, depth):
        self.parts = []
        self.depth = depth

    def __str__(self):
        parts = []
        self._dump(parts)
        return ''.join(parts)

    def _dump(self, parts):
        for part in self.parts:
            if isinstance(part, FractalStringBuilder):
                part._dump(parts)
            else:
                parts.append(str(part))

    def __iadd__(self, line):
        if '\n' in line:
            raise TypeError()
        self('  ' * self.depth + line + '\n')
        return self

    def __call__(self, s):
        self.parts.append(s)
        return self

    def spawn(self, depth_diff=0):
        child = FractalStringBuilder(self.depth + depth_diff)
        self.parts.append(child)
        return child


class FakeType(object):
    @property
    def __name__(self):
        return repr(self)


class ListType(FakeType):
    def __init__(self, subtype):
        self.subtype = subtype

    def __getitem__(self, subtype):
        return ListType(subtype)

    def __instancecheck__(self, obj):
        return (
            isinstance(obj, list) and
            all(isinstance(x, self.subtype) for x in obj))

    def __repr__(self):
        return 'List[%s]' % (self.subtype.__name__, )


List = ListType(object)


class OptionalType(object):
    def __init__(self, subtype):
        self.subtype = subtype

    def __getitem__(self, subtype):
        return OptionalType(subtype)

    def __instancecheck__(self, obj):
        return obj is None or isinstance(obj, self.subtype)

    def __repr__(self):
        return 'Optional[%s]' % (self.subtype.__name__, )


Optional = OptionalType(object)


class Scope(object):
    def __init__(self, parent):
        self.parent = parent
        self.table = dict()
        self.pulled = set()  # set of names that were pulled from parent scope
        self.local_definitions = []

    def _set(self, name, node):
        if name in self.table:
            raise Error([self.table[name].token, node.token],
                        f'Name {name} conflict')
        self.table[name] = node

    def add(self, node):
        self.local_definitions.append(node)
        if isinstance(node, GlobalDefinition):
            self._set(node.name, node)
        elif isinstance(node, BaseVariableDefinition):
            self.validate_vardef(node)
            if isinstance(node, VariableDefinition):
                self._check_for_shadow(node)
            self._set(node.name, node)
        else:
            raise Error([node.token], f'FUBAR: Unrecognized node type {node}')

    def validate_vardef(self, vardef):
        if vardef.type not in PRIMITIVE_TYPES and vardef.type != 'var':
            typenode = self.get(vardef.type, [vardef.token])
            if isinstance(typenode, TraitDefinition):
                raise Error(
                    [vardef.token],
                    f'Using trait types variable type not supported')
            if not isinstance(typenode, TypeDefinition):
                raise Error([vardef.token], f'{vardef.type} is not a type')

    def _check_for_shadow(self, node):
        # We need to take care not to shadow VariableDefinitions.
        # If VariableDefinitions are ever shadowed, they will cause
        # incorrect behavior when the function tries to release
        # all local variables before a return.
        scope = self.parent
        name = node.name
        while scope:
            if name in scope.table and isinstance(scope.table[name], VariableDefinition):
                raise Error([node.token, scope.table[name].token],
                            f'Shadowed local variable')
            scope = scope.parent

    def _missing_name_err(self, name, tokens):
        return Error(tokens, f'Name {name} not defined in this scope')

    def pull(self, name, tokens):
        """Pull a name from parent scope.
        The purpose of doing this is so that if an outer variable is
        used, then a user tries to declare a variable of the same name,
        we want to error out and tell the user that that's funky.
        """
        if name not in self.table:
            if self.parent is None:
                raise self._missing_name_err(name, tokens)
            self.table[name] = self.parent.pull(name, tokens)
            self.pulled.add(name)
        return self.table[name]

    def get(self, name, tokens):
        if name in self.table:
            return self.table[name]
        elif self.parent is not None:
            return self.parent.get(name, tokens)
        raise self._missing_name_err(name, tokens)


class Node(object):
    def __init__(self, token, *args):
        self.token = token
        for (fname, ftype), arg in zip(type(self).fields, args):
            # sys.stderr.write('ftype = %r\n' % (ftype, ))
            if not isinstance(arg, ftype):
                raise TypeError('Expected type of %r to be %r, but got %r' % (
                    fname, ftype, arg))
            try:
                setattr(self, fname, arg)
            except AttributeError:
                sys.stderr.write(f'fname = {fname}\n')
                raise
        if len(type(self).fields) != len(args):
            raise TypeError('%s expects %s arguments, but got %s' % (
                type(self).__name__, len(type(self).fields), len(args)))

    def __repr__(self):
        return '%s(%s)' % (
            type(self).__name__,
            ', '.join(repr(getattr(self, n)) for n, _ in type(self).fields),
        )


def _crelease(ctx, type_, cname):
    if type_ in PRIMITIVE_TYPES:
        return ''
    elif type_ == 'var':
        return f'KLC_release_var({cname});'
    else:
        return f'KLC_release((KLC_header*) {cname});'


def _cretain(ctx, type_, cname):
    if type_ in PRIMITIVE_TYPES:
        return ''
    elif type_ == 'var':
        return f'KLC_retain_var({cname});'
    else:
        return f'KLC_retain((KLC_header*) {cname});'


class BaseVariableDefinition(Node):
    fields = (
        ('type', str),
        ('name', str),
    )

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if self.type == 'void':
            raise Error([self.token], f'Variable of type void is not allowed')

    def cproto(self, ctx):
        return f'{ctx.cdecltype(self.type)} {ctx.cname(self.name)}'

    def cname(self, ctx):
        return ctx.cname(self.name)

    def crelease(self, ctx):
        return _crelease(ctx, self.type, self.cname(ctx))

    def cretain(self, ctx):
        return _cretain(ctx, self.type, self.cname(ctx))


class Parameter(BaseVariableDefinition):
    pass


class Field(BaseVariableDefinition):
    pass


class GlobalDefinition(Node):
    pass


class Statement(Node):
    def translate(self, ctx):
        """Translates self with the given translation context.
        Returns True if the current statement is terminal (e.g. return).
        No statements directly after a translate that returns True should
        be emitted, since those following statements will be unreachable.
        """
        raise NotImplementedError()


class Expression(Node):
    def translate(self, ctx):
        """Translates self with the given translation context.
        Returns (type, tempvar) pair, where type is the type of
        evaluating this expression, and tempvar is the name of the
        temporary C variable where the result of this expression
        is stored.
        If type is 'void', tempvar should be None.
        """
        raise NotImplementedError()


class TranslationContext(object):
    def __init__(self, scope):
        self.scope = scope

    def cdecltype(self, name):
        if name in ('function', 'int', 'bool'):
            return f'KLC_{name}'
        elif name == 'type':
            return f'KLC_typeinfo*'
        if name in PRIMITIVE_TYPES:
            return name
        elif name == 'var':
            return 'KLC_var'
        else:
            return f'{self.cname(name)}*'

    def cname(self, name):
        return f'KLCN{name}'

    def czero(self, name):
        if name == 'type':
            return 'NULL'
        elif name in PRIMITIVE_TYPES:
            return '0'
        elif name == 'var':
            return 'KLC_null'
        else:
            return 'NULL'

    def varify(self, type_, cname):
        if type_ == 'var':
            return cname
        elif type_ in PRIMITIVE_TYPES:
            return f'KLC_{type_}_to_var({cname})'
        else:
            return f'KLC_object_to_var((KLC_header*) {cname})'

    def unvarify(self, type_, cname):
        if type_ == 'var':
            return cname
        elif type_ in PRIMITIVE_TYPES:
            return f'KLC_var_to_{type_}({cname})'
        else:
            return f'({self.cdecltype(type_)}) KLC_var_to_object({cname}, &KLC_type{type_})'


class Name(Expression):
    fields = (
        ('name', str),
    )

    def translate(self, ctx):
        defn = ctx.scope.get(self.name, [self.token])
        if isinstance(defn, BaseVariableDefinition):
            etype = defn.type
            tempvar = ctx.mktemp(etype)
            ctx.src += f'{tempvar} = {ctx.cname(self.name)};'
            ctx.src += _cretain(ctx, etype, tempvar)
            return (etype, tempvar)
        elif isinstance(defn, FunctionDefinition):
            tempvar = ctx.mktemp('var')
            ctx.src += f'{tempvar} = KLC_function_to_var(&KLC_functioninfo{defn.name});'
            return ('var', tempvar)
        else:
            raise Error([self.token, defn.token],
                        f'{name} is not a variable')


class StringLiteral(Expression):
    fields = (
        ('value', str),
    )

    def translate(self, ctx):
        tempvar = ctx.mktemp('String')
        # TODO: properly escape the string literal
        s = (self.value
            .replace('\\', '\\\\')
            .replace('\t', '\\t')
            .replace('\n', '\\n'))
        ctx.src += f'{tempvar} = KLC_mkstr("{s}");'
        return ('String', tempvar)


class IntLiteral(Expression):
    fields = (
        ('value', int),
    )

    def translate(self, ctx):
        tempvar = ctx.mktemp('int')
        # TODO: Warn if size of 'value' is too big
        ctx.src += f'{tempvar} = {self.value}L;'
        return ('int', tempvar)


class DoubleLiteral(Expression):
    fields = (
        ('value', float),
    )

    def translate(self, ctx):
        tempvar = ctx.mktemp('double')
        # TODO: Warn if size of 'value' is too big
        ctx.src += f'{tempvar} = {self.value};'
        return ('double', tempvar)


class FunctionCall(Expression):
    fields = (
        ('function', str),
        ('args', List[Expression]),
    )

    def translate(self, ctx):
        defn = ctx.scope.get(self.function, [self.token])
        if isinstance(defn, FunctionDefinition):
            argtriples = []
            for arg in self.args:
                argtype, argtempvar = arg.translate(ctx)
                argtriples.append((arg.token, argtype, argtempvar))
            return _translate_fcall(ctx, self.token, defn, argtriples)

        if isinstance(defn, BaseVariableDefinition) and defn.type == 'var':
            argtempvars = []
            for arg in self.args:
                argtype, argtempvar = arg.translate(ctx)
                if argtype == 'void':
                    raise Error(
                        [arg.token],
                        'void expression cannot be used as an argument')
                argtempvar = ctx.varify(argtype, argtempvar)
                argtempvars.append(argtempvar)
            tempvar = ctx.mktemp('var')
            nargs = len(self.args)
            temparr = ctx.mktemparr(nargs)
            cfname = ctx.cname(defn.name)
            for i, argtempvar in enumerate(argtempvars):
                ctx.src += f'{temparr}[{i}] = {argtempvar};'
            ctx.src += f'{tempvar} = KLC_var_call({cfname}, {nargs}, {temparr});'
            return ('var', tempvar)

        if isinstance(defn, ClassDefinition):
            if defn.extern:
                raise Error(
                    [self.token],
                    f"You can't call new on an extern class")
            malloc_name = f'KLC_malloc{defn.name}'
            fname = f'{defn.name}_new'
            fdefn = ctx.scope.get(fname, [self.token])
            if not isinstance(fdefn, FunctionDefinition):
                raise Error([self.token], f'FUBAR: shadowed function name')
            this_tempvar = ctx.mktemp(defn.name)
            ctx.src += f'{this_tempvar} = {malloc_name}();'
            argtriples = [(self.token, defn.name, this_tempvar)]
            for arg in self.args:
                argtype, argtempvar = arg.translate(ctx)
                argtriples.append((arg.token, argtype, argtempvar))
            _translate_fcall(ctx, self.token, fdefn, argtriples)
            return (defn.name, this_tempvar)

        raise Error([self.token, defn.token],
                    f'{self.function} is not a function')


def _translate_fcall(ctx, token, defn, argtriples):
    argtempvars = []
    for param, (argtok, argtype, argtempvar) in zip(defn.params, argtriples):
        if argtype != 'void' and param.type == 'var':
            argtempvar = ctx.varify(argtype, argtempvar)
            argtype = 'var'
        if argtype != param.type:
            raise Error([param.token, argtok],
                        f'Expected {param.type} but got {argtype}')
        argtempvars.append(argtempvar)
    if len(defn.params) != len(argtriples):
        raise Error([token, defn.token],
                    f'{len(defn.params)} args expected '
                    f'but got {len(argtriples)}')
    argsstr = ', '.join(argtempvars)
    if defn.return_type == 'void':
        ctx.src += f'{ctx.cname(defn.name)}({argsstr});'
        return ('void', None)
    else:
        tempvar = ctx.mktemp(defn.return_type)
        ctx.src += f'{tempvar} = {ctx.cname(defn.name)}({argsstr});'
        return (defn.return_type, tempvar)


class MethodCall(Expression):
    fields = (
        ('owner', Expression),
        ('name', str),
        ('args', List[Expression]),
    )

    def _no_such_method_error(self, ownertype):
        return Error(
            [self.token],
            f'Method {self.name} does not exist for type {ownertype}')

    def translate(self, ctx):
        ownertype, ownertempvar = self.owner.translate(ctx)
        if ownertype == 'void':
            raise Error([self.token], f'Cannot call method on void type')

        if ownertype == 'var':
            argtempvars = []
            for arg in self.args:
                argtype, argtempvar = arg.translate(ctx)
                if argtype == 'void':
                    raise Error(
                        [arg.token],
                        'void expression cannot be used as an argument')
                argtempvar = ctx.varify(argtype, argtempvar)
                argtempvars.append(argtempvar)
            tarr = ctx.mktemparr(len(self.args) + 1)
            tv = ctx.mktemp('var')
            ctx.src += f'{tarr}[0] = {ownertempvar};'
            for i, argtempvar in enumerate(argtempvars, 1):
                ctx.src += f'{tarr}[{i}] = {argtempvar};'
            ctx.src += f'{tv} = KLC_mcall("{self.name}", {len(self.args) + 1}, {tarr});'
            return ('var', tv)
        else:
            # Check that this method actually exists on this type
            if ownertype in PRIMITIVE_TYPES:
                if self.name not in _primitive_method_names[ownertype]:
                    raise self._no_such_method_error(ownertype)
                fname = f'{ownertype}_m{self.name}'
            else:
                cdef = ctx.scope.get(ownertype, [self.token])
                assert isinstance(cdef, ClassDefinition), cdef
                if self.name not in cdef.method_map(ctx):
                    raise self._no_such_method_error(ownertype)
                fname = cdef.method_map(ctx)[self.name]

            # TODO: Consider looking up from global context
            # to avoid coincidental names that shadow method names
            defn = ctx.scope.get(fname, [self.token])
            if not isinstance(defn, FunctionDefinition):
                raise Error([self.token], f'FUBAR: shadowed method {fname}')

            argtriples = [(self.token, ownertype, ownertempvar)] + [
                (arg.token,) + arg.translate(ctx) for arg in self.args
            ]
            return _translate_fcall(ctx, self.token, defn, argtriples)


class VariableDefinition(Statement, BaseVariableDefinition):
    fields = BaseVariableDefinition.fields + (
        ('expression', Optional[Expression]),
    )

    def translate(self, ctx):
        ctx.scope.add(self)
        if self.expression:
            ectx = ctx.ectx()
            etype, tempvar = self.expression.translate(ectx)
            value = tempvar
            if self.type == 'var' and etype != 'void':
                value = ctx.varify(etype, tempvar)
            elif self.type != etype:
                raise Error([self.token],
                            f'Expected {self.type} but got {etype}')
            ectx.src += f'{self.cname(ectx)} = {value};'
            ectx.release_tempvars(tempvar)


class ExpressionStatement(Statement):
    fields = (
        ('expression', Optional[Expression]),
    )

    def translate(self, ctx):
        ectx = ctx.ectx()
        self.expression.translate(ectx)
        ectx.release_tempvars()


class Return(Statement):
    fields = (
        ('expression', Optional[Expression]),
    )

    def translate(self, ctx):
        ectx = ctx.ectx()
        if self.expression:
            rtype, tempvar = self.expression.translate(ectx)
        else:
            rtype = 'void'
        fctx = ctx.fctx
        expected_rtype = fctx.fdef.return_type
        if expected_rtype != rtype:
            raise Error([fctx.fdef.token, self.token],
                        f'Function was declared to return {expected_rtype} '
                        f'but tried to return {rtype} instead')
        if rtype == 'void':
            _release_for_return(ctx, ectx.src)
            ectx.src += 'return;'
        else:
            ectx.release_tempvars(tempvar)
            _release_for_return(ctx, ectx.src)
            ectx.src += f'return {tempvar};'

        return True


def _release_for_return(ctx, src):
    # Before returning, we should release all local variables
    # We need to take care not to release function parameters
    # or global variables
    scope = ctx.scope
    while scope:
        for vdef in reversed(scope.local_definitions):
            if isinstance(vdef, VariableDefinition):
                src += vdef.crelease(ctx)
        scope = scope.parent


class Block(Statement):
    fields = (
        ('statements', List[Statement]),
    )

    def translate(self, pctx):
        pctx.src += '{'
        prologue = pctx.src.spawn(1)
        ctx = pctx.bctx(1)
        epilogue = pctx.src.spawn(1)
        pctx.src += '}'
        early_return = False
        for i, statement in enumerate(self.statements):
            if statement.translate(ctx):
                early_return = True
                if i + 1 < len(self.statements):
                    raise Error([self.statements[i + 1].token],
                                'Unreachable statement')
                break

        # Declare the local variables for C
        # To be C89 compatible, we need all variable definitions
        # to appear at the beginning of the block.
        for vdef in ctx.scope.local_definitions:
            assert isinstance(vdef, VariableDefinition), vdef
            prologue += f'{vdef.cproto(ctx)} = {ctx.czero(vdef.type)};'

        # If there's an early return, there's no need to have an
        # epilogue and generate unreachable code.
        if not early_return:
            # If we don't have an early return, we should
            # make sure to release all local variables defined in
            # this block before exiting
            # We should also release in LIFO order
            for vdef in reversed(ctx.scope.local_definitions):
                if vdef.type not in PRIMITIVE_TYPES:
                    epilogue += vdef.crelease(ctx)


class GlobalTranslationContext(TranslationContext):
    def __init__(self, program):
        super().__init__(Scope(None))
        self.gctx = self
        for d in program.definitions:
            self.scope.add(d)
        self.out = FractalStringBuilder(0)
        self.out(CPRELUDE)
        self.fwd = self.out.spawn()
        self.hdr = self.out.spawn()
        self.src = self.out.spawn()

    def fctx(self, fdef):
        "Create child function translation context"
        return FunctionTranslationContext(self, fdef)


class BodyTranslationContext(TranslationContext):

    def bctx(self, depth):
        return BlockTranslationContext(self, depth)


class FunctionTranslationContext(BodyTranslationContext):
    def __init__(self, gctx, fdef):
        super().__init__(Scope(gctx.scope))
        for param in fdef.params:
            self.scope.add(param)
        self.parent = gctx
        self.gctx = gctx
        self.fdef = fdef
        self.hdr = gctx.hdr.spawn()
        self.src = gctx.src.spawn()
        self.fctx = self


class BlockTranslationContext(BodyTranslationContext):
    def __init__(self, parent: BodyTranslationContext, depth):
        super().__init__(Scope(parent.scope))
        self.parent = parent
        self.fctx = parent.fctx
        self.gctx = parent.gctx
        self.src = parent.src.spawn(depth)

    def ectx(self):
        return ExpressionTranslationContext(self)


class ExpressionTranslationContext(TranslationContext):
    def __init__(self, parent: BlockTranslationContext):
        super().__init__(parent.scope)
        self.parent = parent
        self.gctx = parent.gctx
        self.tempdecls = []  # (type, cname) pairs of temporary vars
        parent.src += '{'
        self.tmp = parent.src.spawn(1)
        self.src = parent.src.spawn(1)
        parent.src += '}'
        self.next_tempvar_index = 0

    def _next_tempvar_name(self):
        i = self.next_tempvar_index
        self.next_tempvar_index += 1
        return f'tempvar{i}'

    def mktemp(self, type_):
        tempvar = self._next_tempvar_name()
        self.tempdecls.append((type_, tempvar))
        self.tmp += f'{self.cdecltype(type_)} {tempvar} = {self.czero(type_)};'
        return tempvar

    def mktemparr(self, n):
        if n == 0:
            raise Error([], 'FUBAR: zero-length array')
        tempvar = self._next_tempvar_name()
        self.tmp += f'KLC_var {tempvar}[{n}];'
        return tempvar

    def release_tempvars(self, keepvar=None):
        """Release all temporary variables used during expression
        evaluation, except the specified keepvar.
        Variables are released in LIFO order
        """
        for type_, cname in reversed(self.tempdecls):
            if cname != keepvar:
                self.src += _crelease(self, type_, cname)


class Program(Node):
    fields = (
        ('definitions', List[GlobalDefinition]),
    )

    def translate(self):
        ctx = GlobalTranslationContext(self)
        for ptype, mnames in sorted(_primitive_method_names.items()):
            _write_ctypeinfo(ctx.src, ptype, mnames, use_null_deleter=True)
        for d in self.definitions:
            d.translate(ctx)
        return str(ctx.out)


class FunctionDefinition(GlobalDefinition):
    fields = (
        ('return_type', str),
        ('name', str),
        ('params', List[Parameter]),
        ('body', Optional[Block]),
    )

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if self.name == 'main':
            if self.return_type != 'void' or len(self.params):
                raise Error([self.token],
                            'main function must have signature '
                            "'void main()'")

    @property
    def extern(self):
        return self.body is None

    def cproto(self, ctx):
        crt = ctx.cdecltype(self.return_type)
        cname = ctx.cname(self.name)
        cparams = ', '.join(p.cproto(ctx) for p in self.params)
        return f'{crt} {cname}({cparams})'

    def untyped_cproto(self, ctx):
        return f'KLC_var KLC_untyped{self.name}(int argc, KLC_var* argv)'

    def translate(self, gctx: GlobalTranslationContext):
        ctx = gctx.fctx(self)

        rt = self.return_type
        if rt not in PRIMITIVE_TYPES and rt != 'var':
            rtnode = ctx.scope.get(self.return_type, [self.token])
            if isinstance(rtnode, TraitDefinition):
                raise Error(
                    [vardef.token],
                    f'Declaring trait as return type not supported')
            if not isinstance(rtnode, TypeDefinition):
                raise Error([vardef.token], f'{vardef.type} is not a type')

        self._translate_untyped(ctx)

        ctx.hdr += self.cproto(ctx) + ';'
        if self.body:
            ctx.src += self.cproto(ctx)
            self.body.translate(ctx)

    def _translate_untyped(self, ctx):
        name = self.name
        ctx.hdr += self.untyped_cproto(ctx) + ';'
        ctx.hdr += f'KLC_functioninfo KLC_functioninfo{name} = ' '{'
        ctx.hdr += f'  "{name}",'
        ctx.hdr += f'  KLC_untyped{self.name},'
        ctx.hdr += '};'
        ctx.src += self.untyped_cproto(ctx) + '{'
        src = ctx.src.spawn(1)
        ctx.src += '}'
        for i, param in enumerate(self.params):
            src += f'{ctx.cdecltype(param.type)} arg{i};'
        src += f'if (argc != {len(self.params)}) ' '{'
        src += f'  KLC_errorf("Function \'%s\' expected %d args but got %d", \"{self.name}\", {len(self.params)}, argc);'
        src += '}'
        for i, param in enumerate(self.params):
            src += f'arg{i} = {ctx.unvarify(param.type, f"argv[{i}]")};'
        argsstr = ', '.join(f'arg{i}' for i in range(len(self.params)))
        call = f'{ctx.cname(self.name)}({argsstr})'
        if self.return_type == 'void':
            src += f'{call};'
            src += 'return KLC_null;'
        else:
            src += f'return {ctx.varify(self.return_type, call)};'


class TypeDefinition(GlobalDefinition):
    pass


def _delname(cname):
    return f'KLC_delete{cname}'


def _write_ctypeinfo(src, cname, methods, use_null_deleter=False):
    # For primitive types, it's silly to have a deleter, so
    # use_null_deleter allows caller to control this
    if isinstance(methods, list):
        methods = {mname: f'{cname}_m{mname}' for mname in methods}

    del_name = _delname(cname)
    if methods:
        src += f'static KLC_methodinfo KLC_methodarray{cname}[] = ' '{'
        for mname, mfname in sorted(methods.items()):
            src += '  {' f'"{mname}", KLC_untyped{mfname}' '},'
        src += '};'

    src += f'static KLC_methodlist KLC_methodlist{cname} = ' '{'
    src += f'  {len(methods)},'
    src += f'  KLC_methodarray{cname},' if methods else '  NULL,'
    src += '};'

    src += f'KLC_typeinfo KLC_type{cname} = ' '{'
    src += f'  "{cname}",'
    src += '  NULL,' if use_null_deleter else f'  &{del_name},'
    src += f'  &KLC_methodlist{cname},'
    src += '};'


def _check_type_name(token, name):
    if '_' in name:
        raise Error([token], 'Class and trait names cannot have underscores')
    if name[:1].lower() == name[:1]:
        raise Error([token],
                    'Class and trait names must start with uppercase letter')


def _check_all_are_traits(token, traits, ctx):
    for trait_name in traits:
        trait_defn = ctx.scope.get(trait_name, [token])
        if not isinstance(trait_defn, TraitDefinition):
            raise Error([token, trait_defn.token],
                        f'{trait_name} is not a trait')


class TraitDefinition(GlobalDefinition):
    # Trait kind of defines a type, but TraitDefinition not inheriting
    # TypeDefinition is on purpose. Right now, there's no real support
    # for declaring a variable as a trait type.
    fields = (
        ('name', str),
        ('traits', List[str]),
        ('methods', List[str]),
    )

    _trait_method_map = None

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        _check_type_name(self.token, self.name)

    def translate(self, ctx: GlobalTranslationContext):
        # Verify that there's no circular trait inheritance,
        # and in the process, also verify all entries listed in 'traits'
        # are actually defined and are traits.
        self.trait_method_map(ctx)

    def trait_method_map(self, ctx, stack=None):
        if self._trait_method_map is None:
            self._trait_method_map = _compute_method_map(
                token=self.token,
                cname=self.name,
                method_names=self.methods,
                trait_names=self.traits,
                ctx=ctx,
                stack=stack)

        return self._trait_method_map


def _compute_method_map(token, cname, method_names, trait_names, ctx, stack=None):
    ctx = ctx.gctx  # double check that this is the global context
    stack = [] if stack is None else stack
    if cname in stack:
        raise Error([tdef.token for tdef in stack],
                    f'Circular trait inheritance')
    _check_all_are_traits(token, trait_names, ctx)
    method_map = {mname: f'{cname}_m{mname}' for mname in method_names}
    traits = [ctx.scope.get(n, [token]) for n in trait_names]
    stack.append(cname)
    # MRO is DFS
    for trait in traits:
        for mname, mfname in trait.trait_method_map(ctx, stack).items():
            if mname not in method_map:
                method_map[mname] = mfname
    stack.pop()
    return method_map


class ClassDefinition(TypeDefinition):
    fields = (
        ('name', str),
        ('traits', List[str]),
        ('fields', Optional[List[Field]]),
        ('methods', List[str]),
    )

    _method_map = None

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        _check_type_name(self.token, self.name)

    @property
    def extern(self):
        return self.fields is None

    def method_map(self, ctx):
        if self._method_map is None:
            self._method_map = _compute_method_map(
                token=self.token,
                cname=self.name,
                method_names=self.methods,
                trait_names=self.traits,
                ctx=ctx)
        return self._method_map

    def translate(self, ctx: GlobalTranslationContext):
        _check_all_are_traits(self.token, self.traits, ctx)
        name = self.name
        cname = ctx.cname(name)
        cdecltype = ctx.cdecltype(name)

        del_name = _delname(name)
        malloc_name = f'KLC_malloc{name}'

        delete_proto = f'void {del_name}(KLC_header* robj, KLC_header** dq)'
        malloc_proto = f'{cdecltype} {malloc_name}()'

        ctx.hdr += delete_proto + ';'
        ctx.hdr += malloc_proto + ';'

        ctx.hdr += f'extern KLC_typeinfo KLC_type{name};'

        _write_ctypeinfo(
            src=ctx.src,
            cname=name,
            methods=self.method_map(ctx))

        if self.extern:
            return

        # if extern, this typedef should already exist
        ctx.fwd += f'typedef struct {cname} {cname};'

        ctx.hdr += f'struct {cname} ' '{'
        ctx.hdr += '  KLC_header header;'
        for field in self.fields:
            ctx.hdr += f'  {field.cproto(ctx)};'
        ctx.hdr += '};'

        ctx.src += delete_proto + ' {'
        objfields = [f for f in self.fields if f.type not in PRIMITIVE_TYPES]
        if objfields:
            ctx.src += f'  {cdecltype} obj = ({cdecltype}) robj;'
            for field in objfields:
                cfname = ctx.cname(field.name)
                if field.type == 'var':
                    ctx.src += f'  KLC_partial_release_var(obj->{cfname}, dq);'
                else:
                    ctx.src += f'  KLC_partial_release((KLC_header*) obj->{cfname}, dq);'
        ctx.src += '}'

        ctx.src += malloc_proto + ' {'
        ctx.src += f'  {cdecltype} obj = ({cdecltype}) malloc(sizeof({cname}));'
        ctx.src += f'  KLC_init_header(&obj->header, &KLC_type{name});'
        for field in self.fields:
            cfname = ctx.cname(field.name)
            ctx.src += f'  obj->{cfname} = {ctx.czero(field.type)};'
        ctx.src += '  return obj;'
        ctx.src += '}'



def parse(source):
    tokens = lex(source)
    i = 0

    def peek(j=0):
        return tokens[min(i + j, len(tokens) - 1)]

    def at(type, j=0):
        return peek(j).type == type

    def gettok():
        nonlocal i
        i += 1
        return tokens[i - 1]

    def consume(type):
        if at(type):
            return gettok()

    def expect(type):
        if not at(type):
            raise Error([peek()], f'Expected {type} but got {peek()}')
        return gettok()

    def parse_program():
        token = peek()
        defs = []
        while not at('EOF'):
            parse_global_definition(defs)
        return Program(token, defs)

    def parse_global_definition(defs):
        if at('trait'):
            parse_trait_definition(defs)
            return

        if at('class') or at('extern') and at('class', 1):
            parse_class_definition(defs)
            return

        if at('NAME') and at('NAME', 1) and at('(', 2):
            parse_function_definition(defs)
            return

        raise Error([peek()], f'Expected class, function or variable definition')

    def parse_function_definition(defs):
        token = peek()
        return_type = expect('NAME').value
        nametoken = peek()
        name = expect('NAME').value
        if name[:1].lower() != name[:1]:
            raise Error(
                [nametoken],
                f'Function names should not start with uppercase letters')
        params = parse_params()
        if at('{'):
            body = parse_block()
        else:
            body = None
            expect(';')
        defs.append(FunctionDefinition(token, return_type, name, params, body))

    def parse_class_definition(defs):
        token = peek()
        extern = bool(consume('extern'))
        expect('class')
        name = expect('NAME').value
        traits = parse_trait_list()
        method_to_token_table = dict()
        fields = None if extern else []
        newdef = None
        expect('{')
        while not consume('}'):
            if at('new'):
                if extern:
                    raise Error(
                        [peek()],
                        f'extern classes cannot define constructors')
                if newdef is not None:
                    raise Error(
                        [newdef.token, peek()],
                        'Only one constructor definition is allowed for '
                        'a class')
                fname = f'{name}_new'
                mtoken = expect('new')
                params = [Parameter(mtoken, name, 'this')] + parse_params()
                body = parse_block()
                newdef = FunctionDefinition(mtoken, 'void', fname, params, body)
                defs.append(newdef)
            elif at('NAME') and at('NAME', 1) and at(';', 2):
                if extern:
                    raise Error(
                        [peek()],
                        'Extern classes cannot declare fields '
                        f'(in definition of class {name})')
                ftoken = peek()
                ftype = expect('NAME').value
                fname = expect('NAME').value
                expect(';')
                fields.append(Field(ftoken, ftype, fname))
            else:
                mtoken = peek()
                rtype = expect('NAME').value
                mname = expect('NAME').value
                params = [Parameter(mtoken, name, 'this')] + parse_params()
                if extern:
                    body = None
                    expect(';')
                else:
                    body = parse_block()

                # A method is mapped to a function with a special name,
                # and an implicit first parameter.
                fname = f'{name}_m{mname}'

                if mname in method_to_token_table:
                    raise Error([method_to_token_table[mname], mtoken],
                                f'Duplicate method {name}.{mname}')

                method_to_token_table[mname] = mtoken

                defs.append(FunctionDefinition(mtoken, rtype, fname, params, body))

        if not extern and newdef is None:
            defs.append(FunctionDefinition(
                token,
                'void',
                f'{name}_new',
                [Parameter(mtoken, name, 'this')],
                Block(token, [])))

        method_names = sorted(method_to_token_table)
        defs.append(ClassDefinition(token, name, traits, fields, method_names))

    def parse_trait_definition(defs):
        token = expect('trait')
        name = expect('NAME').value
        method_to_token_table = dict()
        traits = parse_trait_list()
        expect('{')
        while not consume('}'):
            mtoken = peek()
            rtype = expect('NAME').value
            mname = expect('NAME').value
            params = parse_params()
            body = parse_block()

            # A method is mapped to a function with a special name,
            # and an implicit first parameter.
            fname = f'{name}_m{mname}'
            params = [Parameter(mtoken, 'var', 'this')] + params

            if mname in method_to_token_table:
                raise Error([method_to_token_table[mname], mtoken],
                            f'Duplicate method {name}.{mname}')

            method_to_token_table[mname] = mtoken

            defs.append(FunctionDefinition(mtoken, rtype, fname, params, body))

        method_names = sorted(method_to_token_table)
        defs.append(TraitDefinition(token, name, traits, method_names))

    def parse_trait_list():
        traits = []
        if consume('('):
            while not consume(')'):
                traits.append(expect('NAME').value)
                if not consume(','):
                    expect(')')
                    break
        return traits

    def parse_block():
        token = expect('{')
        statements = []
        while not consume('}'):
            statements.append(parse_statement())
        return Block(token, statements)

    def parse_statement():
        token = peek()

        if at('{'):
            return parse_block()

        if at('NAME') and at('NAME', 1):
            return parse_variable_definition()

        if consume('return'):
            expression = None if at(';') else parse_expression()
            expect(';')
            return Return(token, expression)

        expression = parse_expression()
        expect(';')
        return ExpressionStatement(token, expression)

    def parse_expression():
        return parse_relational()

    def parse_relational():
        expr = parse_additive()
        while True:
            token = peek()
            if consume('=='):
                expr = MethodCall(token, expr, 'Eq', [parse_additive()])
            elif consume('!='):
                expr = MethodCall(token, expr, 'Ne', [parse_additive()])
            elif consume('<'):
                expr = MethodCall(token, expr, 'Lt', [parse_additive()])
            elif consume('<='):
                expr = MethodCall(token, expr, 'Le', [parse_additive()])
            elif consume('>'):
                expr = MethodCall(token, expr, 'Gt', [parse_additive()])
            elif consume('>='):
                expr = MethodCall(token, expr, 'Ge', [parse_additive()])
            else:
                break
        return expr

    def parse_additive():
        expr = parse_multiplicative()
        while True:
            token = peek()
            if consume('+'):
                expr = MethodCall(token, expr, 'Add', [parse_multiplicative()])
            elif consume('-'):
                expr = MethodCall(token, expr, 'Sub', [parse_multiplicative()])
            else:
                break
        return expr

    def parse_multiplicative():
        expr = parse_unary()
        while True:
            token = peek()
            if consume('*'):
                expr = MethodCall(token, expr, 'Mul', [parse_unary()])
            elif consume('/'):
                expr = MethodCall(token, expr, 'Div', [parse_unary()])
            elif consume('%'):
                expr = MethodCall(token, expr, 'Mod', [parse_unary()])
            else:
                break
        return expr

    def parse_unary():
        token = peek()
        if consume('-'):
            expr = parse_pow()
            return MethodCall(token, expr, 'Not', [])
        return parse_pow()

    def parse_pow():
        expr = parse_postfix()
        token = peek()
        if consume('**'):
            return MethodCall(token, expr, 'Pow', [parse_pow()])
        return expr

    def parse_postfix():
        token = peek()
        expr = parse_primary()
        while True:
            if consume('.'):
                name = expect('NAME').value
                args = parse_args()
                return MethodCall(token, expr, name, args)
            break
        return expr

    def parse_primary():
        token = peek()

        if consume('('):
            expr = parse_expression()
            expect(')')
            return expr

        if at('INT'):
            value = expect('INT').value
            return IntLiteral(token, value)

        if at('FLOAT'):
            value = expect('FLOAT').value
            return DoubleLiteral(token, value)

        if at('NAME'):
            name = expect('NAME').value
            if at('('):
                args = parse_args()
                return FunctionCall(token, name, args)
            else:
                return Name(token, name)

        if at('STRING'):
            return StringLiteral(token, expect('STRING').value)

        raise Error([token], 'Expected expression')

    def parse_variable_definition():
        token = peek()
        vartype = expect('NAME').value
        name = expect('NAME').value
        value = parse_expression() if consume('=') else None
        expect(';')
        return VariableDefinition(token, vartype, name, value)

    def parse_args():
        args = []
        expect('(')
        while not consume(')'):
            args.append(parse_expression())
            if not consume(','):
                expect(')')
                break
        return args

    def parse_params():
        params = []
        expect('(')
        while not consume(')'):
            paramtoken = peek()
            paramtype = expect('NAME').value
            paramname = expect('NAME').value
            params.append(Parameter(paramtoken, paramtype, paramname))
            if not consume(','):
                expect(')')
                break
        return params

    return parse_program()


tok = lex(Source('<dummy>', 'dummy'))[0]

# node = Program(tok, [
#     ClassDefinition(tok, 'String', None, ['size']),
#     FunctionDefinition(tok, 'String', 'str', [Parameter(tok, 'var', 'v')], None),
#     FunctionDefinition(tok, 'int', 'String_msize',
#                        [Parameter(tok, 'String', 's')], None),
#     ClassDefinition(tok, 'Foo', [
#         Field(tok, 'var', 'v'),
#         Field(tok, 'int', 'i'),
#         Field(tok, 'String', 's'),
#     ], []),
#     FunctionDefinition(tok, 'void', 'foo', [Parameter(tok, 'var', 'callback')], Block(tok, [
#         ExpressionStatement(tok, FunctionCall(tok, 'callback', [StringLiteral(tok, 'hi')])),
#     ])),
#     FunctionDefinition(tok, 'void', 'puts', [Parameter(tok, 'String', 'x')], None),
#     FunctionDefinition(tok, 'String', 'id', [Parameter(tok, 'String', 'x')], Block(tok, [
#         Return(tok, StringLiteral(tok, 'id-result')),
#     ])),
#     FunctionDefinition(tok, 'void', 'print', [Parameter(tok, 'var', 'v')], Block(tok, [
#         ExpressionStatement(tok, FunctionCall(tok, 'puts', [
#             FunctionCall(tok, 'str', [Name(tok, 'v')]),
#         ])),
#     ])),
#     FunctionDefinition(tok, 'void', 'main', [], Block(tok, [
#         ExpressionStatement(tok, FunctionCall(
#             tok, 'puts', [StringLiteral(tok, 'Hello world!')]
#         )),
#         VariableDefinition(tok, "String", "s", StringLiteral(tok, "Hello world2")),
#         VariableDefinition(tok, "var", "v", StringLiteral(tok, "Hello world2")),
#         ExpressionStatement(tok, FunctionCall(tok, 'puts', [Name(tok, 's')])),
#         ExpressionStatement(tok, FunctionCall(tok, 'puts', [
#             FunctionCall(tok, 'id', [StringLiteral(tok, 'id-arg')]),
#         ])),
#         ExpressionStatement(tok, FunctionCall(tok, 'foo', [Name(tok, 'puts')])),
#         ExpressionStatement(tok, FunctionCall(tok, 'print', [Name(tok, 'foo')])),
#         ExpressionStatement(tok, FunctionCall(tok, 'print', [
#             MethodCall(tok, Name(tok, 'v'), 'size', []),
#         ])),
#         ExpressionStatement(tok, FunctionCall(tok, 'print', [
#             MethodCall(tok, Name(tok, 's'), 'size', []),
#         ])),
#     ])),
# ])

BUILTINS = """
// These are explicit function names for primitive types
// These methods must also be explicitly listed in the
// _primitive_method_names dictionary above, and of course
// actually implemented in the C code.
// TODO: Implement a more elegant mechanism for enumerating
// primitive type methods.
int int_mAdd(int a, int b);
int int_mSub(int a, int b);
bool int_mEq(int a, int b);

extern class String {
  int bytesize();
  int size();
  String Add(String b);
}
"""

builtins_node = parse(Source('<builtin>', BUILTINS))

parser = argparse.ArgumentParser()
parser.add_argument('kfile')

def main():
    args = parser.parse_args()
    with open(args.kfile) as f:
        data = f.read()
    source = Source(args.kfile, data)
    node = parse(source)
    program = Program(node.token, node.definitions + builtins_node.definitions)
    print(program.translate())

if __name__ == '__main__':
    main()
