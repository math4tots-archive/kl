"""
From powershell:
$PSDefaultParameterValues['Out-File:Encoding'] = 'utf8'
python .\klc.py > main.c

From linux subsystem for windows:
gcc -std=c89 -Werror -Wpedantic -Wall -Wno-unused-function -Wno-unused-variable main.c && \
cp main.{c,cc} && \
g++ -std=c++98 -Werror -Wpedantic -Wall -Wno-unused-function -Wno-unused-variable main.cc && \
./a.out
"""
from typing import NamedTuple, Tuple, List, Union, Optional, Callable, Iterable
import abc
import re
import typing
import contextlib
import sys


SYMBOLS = [
    ';',
    '.', ',', '!', '@', '^', '&', '+', '-', '/', '%', '*', '.', '=', '==', '<',
    '>', '<=', '>=', '(', ')', '{', '}', '[', ']',
]

KEYWORDS = {'class', 'trait', 'if', 'else', 'while', 'break', 'continue'}

PRIMITIVE_TYPES = {
    'void',
    'int',
    'long',
    'size_t',
    'double',
    'function',
}


PRELUDE = r"""/* Autogenerated by the KL Compiler */
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define KLC_TAG_INT 0
#define KLC_TAG_LONG 1
#define KLC_TAG_SIZE_T 2
#define KLC_TAG_DOUBLE 3
#define KLC_TAG_FUNCTION 4
#define KLC_TAG_OBJECT 5

typedef struct KLC_header KLC_header;
typedef struct KLC_typeinfo KLC_typeinfo;
typedef struct KLC_var KLC_var;
typedef KLC_var (*KLC_Function)(int, KLC_var*);

struct KLC_header {
  KLC_typeinfo* type;
  size_t refcnt;
  KLC_header* next;
};

struct KLC_typeinfo {
  const char* name;
  void (*deleter)(KLC_header*, KLC_header**);
};

struct KLC_var {
  int tag;
  union {
    KLC_header* obj;
    int i;
    long l;
    size_t s;
    double d;
    KLC_Function f;
  } u;
};

void KLC_errorf(const char* fmt, ...) {
  int* i = NULL;
  va_list args;
  va_start(args, fmt);
  vfprintf(stderr, fmt, args);
  va_end(args);
  printf("%d\n", *i);
}

void KLC_retain(KLC_header *obj) {
  if (obj) {
    obj->refcnt++;
  }
}

void KLC_retain_var(KLC_var v) {
  if (v.tag == KLC_TAG_OBJECT) {
    KLC_retain(v.u.obj);
  }
}

void KLC_partial_release(KLC_header* obj, KLC_header** delete_queue) {
  if (obj) {
    if (obj->refcnt) {
      obj->refcnt--;
    } else {
      obj->next = *delete_queue;
      *delete_queue = obj;
    }
  }
}

void KLC_partial_release_var(KLC_var v, KLC_header** delete_queue) {
  if (v.tag == KLC_TAG_OBJECT) {
    KLC_partial_release(v.u.obj, delete_queue);
  }
}

void KLC_release(KLC_header *obj) {
  KLC_header* delete_queue = NULL;
  KLC_partial_release(obj, &delete_queue);
  while (delete_queue) {
    obj = delete_queue;
    delete_queue = delete_queue->next;
    obj->type->deleter(obj, &delete_queue);
    free(obj);
  }
}

void KLC_release_var(KLC_var v) {
  if (v.tag == KLC_TAG_OBJECT) {
    KLC_release(v.u.obj);
  }
}

KLC_var KLC_int_to_var(int i) {
  KLC_var ret;
  ret.tag = KLC_TAG_INT;
  ret.u.i = i;
  return ret;
}

KLC_var KLC_long_to_var(long l) {
  KLC_var ret;
  ret.tag = KLC_TAG_LONG;
  ret.u.l = l;
  return ret;
}

KLC_var KLC_size_t_to_var(size_t s) {
  KLC_var ret;
  ret.tag = KLC_TAG_SIZE_T;
  ret.u.s = s;
  return ret;
}

KLC_var KLC_double_to_var(double d) {
  KLC_var ret;
  ret.tag = KLC_TAG_DOUBLE;
  ret.u.d = d;
  return ret;
}

KLC_var KLC_function_to_var(KLC_Function f) {
  KLC_var ret;
  ret.tag = KLC_TAG_FUNCTION;
  ret.u.f = f;
  return ret;
}

KLC_var KLC_object_to_var(KLC_header* obj) {
  KLC_var ret;
  ret.tag = KLC_TAG_OBJECT;
  ret.u.obj = obj;
  return ret;
}

KLC_header* KLC_var_to_object(KLC_var v, KLC_typeinfo* ti) {
  /* TODO: Better error message */
  KLC_header* ret;
  if (v.tag != KLC_TAG_OBJECT) {
    KLC_errorf("var_to_object: not an object\n");
  }
  if (ti != v.u.obj->type) {
    KLC_errorf("var_to_object: not the right object type\n");
  }
  return v.u.obj;
}

KLC_var KLC_var_call(KLC_var f, int argc, KLC_var* argv) {
  /* TODO: Better error message */
  KLC_var result;

  if (f.tag != KLC_TAG_FUNCTION) {
    KLC_errorf("Not a function\n");
  }

  result = f.u.f(argc, argv);

  return result;
}

typedef struct KLCNString KLCNString;
struct KLCNString {
  KLC_header header;
  size_t size;
  char *buffer;
};

void KLC_deleteString(KLC_header* robj, KLC_header** dq) {
  KLCNString *obj = (KLCNString*) robj;
  free(obj->buffer);
}

KLC_typeinfo KLC_typeString = {
  "String",
  KLC_deleteString
};

KLCNString* KLC_mkstr(const char *str) {
  KLCNString* obj = (KLCNString*) malloc(sizeof(KLCNString));
  size_t len = strlen(str);
  char* buffer = (char*) malloc(sizeof(char) * (len + 1));
  strcpy(buffer, str);
  obj->header.type = &KLC_typeString;
  obj->header.refcnt = 0;
  obj->header.next = NULL;
  obj->size = len;
  obj->buffer = buffer;
  return obj;
}

void KLCNputs(KLCNString *s) {
  printf("%s\n", s->buffer);
}

void KLCNmain();

static KLC_var KLC_zero = {
  KLC_TAG_OBJECT,
  { NULL }
};

int main() {
  KLCNmain();
  return 0;
}

"""


class Source(NamedTuple):
    filename: str
    data: str


class Token:
    __slots__ = ['type', 'value', 'source', 'i']

    def __init__(self,
                 type: str,
                 value: object = None,
                 source: Optional[Source] = None,
                 i: Optional[int] = None) -> None:
        self.type = type
        self.value = value
        self.source = source
        self.i = i

    def _key(self) -> Tuple[str, object]:
        return self.type, self.value

    def __eq__(self, other: object) -> bool:
        return isinstance(other, Token) and self._key() == other._key()

    def __hash__(self) -> int:
        return hash(self._key())

    def __repr__(self) -> str:
        return f'Token({repr(self.type)}, {repr(self.value)})'

    @property
    def lineno(self) -> int:
        assert self.source is not None
        assert self.i is not None
        return self.source.data.count('\n', 0, self.i) + 1

    @property
    def colno(self) -> int:
        assert self.source is not None
        assert self.i is not None
        return self.i - self.source.data.rfind('\n', 0, self.i)

    @property
    def line(self) -> str:
        assert self.source is not None
        assert self.i is not None
        s = self.source.data
        a = s.rfind('\n', 0, self.i) + 1
        b = s.find('\n', self.i)
        if b == -1:
            b = len(s)
        return s[a:b]

    @property
    def info(self) -> str:
        line = self.line
        colno = self.colno
        lineno = self.lineno
        spaces = ' ' * (colno - 1)
        return f'on line {lineno}\n{line}\n{spaces}*\n'


class Error(Exception):
    def __init__(self, tokens: Iterable[Token], message: str) -> None:
        super().__init__(''.join(token.info for token in tokens) + message)


class Pattern(abc.ABC):
    @abc.abstractmethod
    def match(self, source: Source, i: int) -> Optional[Tuple[Token, int]]:
        pass


class RegexPattern(Pattern):
    def __init__(
            self,
            regex: Union[typing.Pattern[str], str],
            *,
            type: Optional[str] = None,
            type_callback: Callable[[str], str] = lambda value: value,
            value_callback: Callable[[str], object] = lambda x: x) -> None:
        if isinstance(regex, str):
            regex = re.compile(regex)

        if type is not None:
            type_ = str(type)  # for mypy
            type_callback = lambda _: type_

        self.regex = regex
        self.type_callback = type_callback
        self.value_callback = value_callback

    def match(self, source: Source, i: int) -> Optional[Tuple[Token, int]]:
        m = self.regex.match(source.data, i)
        if m is None:
            return None

        raw_value = m.group()
        type_ = self.type_callback(raw_value)
        value = self.value_callback(raw_value)
        return Token(type_, value, source, i), m.end()


def _make_lexer():
    whitespace_pattern = RegexPattern(r'\s+')

    class Lexer:
        def __init__(
                self,
                patterns: List[Pattern],
                *,
                ignore_pattern: Pattern,
                filter: Callable[[Token], Optional[Token]] = lambda token: token
        ) -> None:
            self.patterns = patterns
            self.ignore_pattern = ignore_pattern
            self.filter = filter

        def lex(self, source: Union[Source, str]) -> List[Token]:
            if isinstance(source, str):
                source = Source('<string>', source)

            ignore_pattern = self.ignore_pattern
            i = 0
            s = source.data
            tokens = []

            while True:
                while True:
                    match = ignore_pattern.match(source, i)
                    if match is None:
                        break
                    _, i = match

                if i >= len(s):
                    break

                for pattern in self.patterns:
                    match = pattern.match(source, i)
                    if match is not None:
                        unfiltered_token, i = match
                        token = self.filter(unfiltered_token)
                        if token is not None:
                            tokens.append(token)
                        break
                else:
                    token = Token('ERR', None, source, i)
                    raise Error([token], 'Unrecognized token')

            tokens.append(Token('EOF', None, source, i))
            return tokens

    class MatchingBracesSkipSpacesFilter:
        """A lexer filter for ignoring newlines that appear inside parentheses
        or square brackets.
        """

        def __init__(self) -> None:
            self.stack: List[Token] = []

        def should_skip_newlines(self) -> bool:
            return bool(self.stack and self.stack[-1].type != '{')

        def __call__(self, token: Token) -> Optional[Token]:
            if token.type in ('{', '[', '('):
                self.stack.append(token)

            if token.type in ('}', ']', ')'):
                self.stack.pop()

            if token.type == '\n' and self.should_skip_newlines():
                return None

            return token

    def make_symbols_pattern(symbols: Iterable[str]) -> Pattern:
        return RegexPattern('|'.join(map(re.escape, reversed(sorted(symbols)))))

    def make_keywords_pattern(keywords: Iterable[str]) -> Pattern:
        return RegexPattern('|'.join(r'\b' + kw + r'\b' for kw in keywords))

    name_pattern = RegexPattern(
        '\w+', type='NAME', value_callback=lambda value: value)

    def string_pattern_value_callback(value: str) -> str:
        return str(eval(value))  # type: ignore

    string_pattern_regex = '|'.join([
        r'(?:r)?"""(?:(?:\\.)|(?!""").)*"""',
        r"(?:r)?'''(?:(?:\\.)|(?!''').)*'''",
        r'(?:r)?"(?:(?:\\.)|(?!").)*"',
        r"(?:r)?'(?:(?:\\.)|(?!').)*'",
    ])

    string_pattern = RegexPattern(
        string_pattern_regex,
        type='STRING',
        value_callback=string_pattern_value_callback)

    float_pattern = RegexPattern(
        r'\d+\.\d*|\.\d+', type='FLOAT', value_callback=eval)  # type: ignore
    int_pattern = RegexPattern(
        r'\d+', type='INT', value_callback=eval)  # type: ignore

    def make_simple_lexer(*, keywords: Iterable[str], symbols: Iterable[str]):
        keywords_pattern = make_keywords_pattern(keywords)
        symbols_pattern = make_symbols_pattern(symbols)
        return Lexer(
            [
                string_pattern,
                keywords_pattern,
                float_pattern,
                int_pattern,
                name_pattern,
                symbols_pattern,
            ],
            ignore_pattern=whitespace_pattern)

    return make_simple_lexer(keywords=KEYWORDS, symbols=SYMBOLS)


_lexer = _make_lexer()


def lex(source):
    return _lexer.lex(source)


class FractalStringBuilder(object):
    def __init__(self, depth):
        self.parts = []
        self.depth = depth

    def __str__(self):
        parts = []
        self._dump(parts)
        return ''.join(parts)

    def _dump(self, parts):
        for part in self.parts:
            if isinstance(part, FractalStringBuilder):
                part._dump(parts)
            else:
                parts.append(str(part))

    def __iadd__(self, line):
        if '\n' in line:
            raise TypeError()
        self('  ' * self.depth + line + '\n')
        return self

    def __call__(self, s):
        self.parts.append(s)
        return self

    def spawn(self, depth_diff=0):
        child = FractalStringBuilder(self.depth + depth_diff)
        self.parts.append(child)
        return child


class FakeType(object):
    @property
    def __name__(self):
        return repr(self)


class ListType(FakeType):
    def __init__(self, subtype):
        self.subtype = subtype

    def __getitem__(self, subtype):
        return ListType(subtype)

    def __instancecheck__(self, obj):
        return (
            isinstance(obj, list) and
            all(isinstance(x, self.subtype) for x in obj))

    def __repr__(self):
        return 'List[%s]' % (self.subtype.__name__, )


List = ListType(object)


class OptionalType(object):
    def __init__(self, subtype):
        self.subtype = subtype

    def __getitem__(self, subtype):
        return OptionalType(subtype)

    def __instancecheck__(self, obj):
        return obj is None or isinstance(obj, self.subtype)

    def __repr__(self):
        return 'Optional[%s]' % (self.subtype.__name__, )


Optional = OptionalType(object)


class Scope(object):
    def __init__(self, parent):
        self.parent = parent
        self.table = dict()
        self.pulled = set()  # set of names that were pulled from parent scope
        self.local_definitions = []

    def _set(self, name, node):
        if name in self.table:
            raise Error([self.table[name].token, node.token],
                        f'Name {name} conflict')
        self.table[name] = node

    def add(self, node):
        self.local_definitions.append(node)
        if isinstance(node, GlobalDefinition):
            self._set(node.name, node)
        elif isinstance(node, BaseVariableDefinition):
            self.validate_vardef(node)
            if isinstance(node, VariableDefinition):
                self._check_for_shadow(node)
            self._set(node.name, node)
        else:
            raise Error([node.token], f'FUBAR: Unrecognized node type {node}')

    def validate_vardef(self, vardef):
        if vardef.type not in PRIMITIVE_TYPES and vardef.type != 'var':
            typenode = self.get(vardef.type, [vardef.token])
            if not isinstance(typenode, TypeDefinition):
                raise Error([vardef.token], f'{vardef.type} is not a type')

    def _check_for_shadow(self, node):
        # We need to take care not to shadow VariableDefinitions.
        # If VariableDefinitions are ever shadowed, they will cause
        # incorrect behavior when the function tries to release
        # all local variables before a return.
        scope = self.parent
        name = node.name
        while scope:
            if name in scope.table and isinstance(scope.table[name], VariableDefinition):
                raise Error([node.token, scope.table[name].token],
                            f'Shadowed local variable')
            scope = scope.parent

    def _missing_name_err(self, name, tokens):
        return Error(tokens, f'Name {name} not defined in this scope')

    def pull(self, name, tokens):
        """Pull a name from parent scope.
        The purpose of doing this is so that if an outer variable is
        used, then a user tries to declare a variable of the same name,
        we want to error out and tell the user that that's funky.
        """
        if name not in self.table:
            if self.parent is None:
                raise self._missing_name_err(name, tokens)
            self.table[name] = self.parent.pull(name, tokens)
            self.pulled.add(name)
        return self.table[name]

    def get(self, name, tokens):
        if name in self.table:
            return self.table[name]
        elif self.parent is not None:
            return self.parent.get(name, tokens)
        raise self._missing_name_err(name, tokens)


class Node(object):
    def __init__(self, token, *args):
        self.token = token
        for (fname, ftype), arg in zip(type(self).fields, args):
            # sys.stderr.write('ftype = %r\n' % (ftype, ))
            if not isinstance(arg, ftype):
                raise TypeError('Expected type of %r to be %r, but got %r' % (
                    fname, ftype, arg))
            try:
                setattr(self, fname, arg)
            except AttributeError:
                sys.stderr.write(f'fname = {fname}\n')
                raise
        if len(type(self).fields) != len(args):
            raise TypeError('%s expects %s arguments, but got %s' % (
                type(self).__name__, len(type(self).fields), len(args)))

    def __repr__(self):
        return '%s(%s)' % (
            type(self).__name__,
            ', '.join(repr(getattr(self, n)) for n, _ in type(self).fields),
        )


def _crelease(ctx, type_, cname):
    if type_ in PRIMITIVE_TYPES:
        return ''
    elif type_ == 'var':
        return f'KLC_release_var({cname});'
    else:
        return f'KLC_release((KLC_header*) {cname});'


def _cretain(ctx, type_, cname):
    if type_ in PRIMITIVE_TYPES:
        return ''
    elif type_ == 'var':
        return f'KLC_retain_var({cname});'
    else:
        return f'KLC_retain((KLC_header*) {cname});'


class BaseVariableDefinition(Node):
    fields = (
        ('type', str),
        ('name', str),
    )

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if self.type == 'void':
            raise Error([self.token], f'Variable of type void is not allowed')

    def cproto(self, ctx):
        return f'{ctx.cdecltype(self.type)} {ctx.cname(self.name)}'

    def cname(self, ctx):
        return ctx.cname(self.name)

    def crelease(self, ctx):
        return _crelease(ctx, self.type, self.cname(ctx))

    def cretain(self, ctx):
        return _cretain(ctx, self.type, self.cname(ctx))


class Parameter(BaseVariableDefinition):
    pass


class Field(BaseVariableDefinition):
    pass


class GlobalDefinition(Node):
    pass


class Statement(Node):
    def translate(self, ctx):
        """Translates self with the given translation context.
        Returns True if the current statement is terminal (e.g. return).
        No statements directly after a translate that returns True should
        be emitted, since those following statements will be unreachable.
        """
        raise NotImplementedError()


class Expression(Node):
    def translate(self, ctx):
        """Translates self with the given translation context.
        Returns (type, tempvar) pair, where type is the type of
        evaluating this expression, and tempvar is the name of the
        temporary C variable where the result of this expression
        is stored.
        If type is 'void', tempvar should be None.
        """
        raise NotImplementedError()


class TranslationContext(object):
    def __init__(self, scope):
        self.scope = scope

    def cdecltype(self, name):
        if name in PRIMITIVE_TYPES:
            if name == 'function':
                return 'KLC_Function'
            else:
                return name
        elif name == 'var':
            return 'KLC_var'
        else:
            return f'{self.cname(name)}*'

    def cname(self, name):
        return f'KLCN{name}'

    def czero(self, name):
        if name in PRIMITIVE_TYPES:
            return '0'
        elif name == 'var':
            return 'KLC_zero'
        else:
            return 'NULL'

    def varify(self, type_, cname):
        if type_ == 'var':
            return cname
        elif type_ in PRIMITIVE_TYPES:
            return f'KLC_{type_}_to_var({cname})'
        else:
            return f'KLC_object_to_var((KLC_header*) {cname})'

    def unvarify(self, type_, cname):
        if type_ == 'var':
            return cname
        elif type_ in PRIMITIVE_TYPES:
            return f'KLC_var_to_{type_}({cname})'
        else:
            return f'({self.cdecltype(type_)}) KLC_var_to_object({cname}, &KLC_type{type_})'


class Name(Expression):
    fields = (
        ('name', str),
    )

    def translate(self, ctx):
        defn = ctx.scope.get(self.name, [self.token])
        if isinstance(defn, BaseVariableDefinition):
            etype = defn.type
            tempvar = ctx.mktemp(etype)
            ctx.src += f'{tempvar} = {ctx.cname(self.name)};'
            ctx.src += _cretain(ctx, etype, tempvar)
            return (etype, tempvar)
        elif isinstance(defn, FunctionDefinition):
            tempvar = ctx.mktemp('var')
            ctx.src += f'{tempvar} = KLC_function_to_var(KLC_untyped{defn.name});'
            return ('var', tempvar)
        else:
            raise Error([self.token, defn.token],
                        f'{name} is not a variable')


class StringLiteral(Expression):
    fields = (
        ('value', str),
    )

    def translate(self, ctx):
        tempvar = ctx.mktemp('String')
        # TODO: properly escape the string literal
        s = (self.value
            .replace('\\', '\\\\')
            .replace('\t', '\\t')
            .replace('\n', '\\n'))
        ctx.src += f'{tempvar} = KLC_mkstr("{s}");'
        return ('String', tempvar)


class FunctionCall(Expression):
    fields = (
        ('function', str),
        ('args', List[Expression]),
    )

    def translate(self, ctx):
        defn = ctx.scope.get(self.function, [self.token])
        if isinstance(defn, FunctionDefinition):
            argtempvars = []
            for param, arg in zip(defn.params, self.args):
                argtype, argtempvar = arg.translate(ctx)
                if argtype != 'void' and param.type == 'var':
                    argtempvar = ctx.varify(argtype, argtempvar)
                if argtype != param.type:
                    raise Error([param.token, arg.token],
                                f'Expected {param.type} but got {argtype}')
                argtempvars.append(argtempvar)
            if len(defn.params) != len(self.args):
                raise Error([self.token, defn.token],
                            f'{len(defn.params)} args expected '
                            f'but got {len(self.args)}')
            argsstr = ', '.join(argtempvars)
            if defn.return_type is 'void':
                ctx.src += f'{ctx.cname(defn.name)}({argsstr});'
                return ('void', None)
            else:
                tempvar = ctx.mktemp(defn.return_type)
                ctx.src += f'{tempvar} = {ctx.cname(defn.name)}({argsstr});'
                return (defn.return_type, tempvar)

        if isinstance(defn, BaseVariableDefinition) and defn.type == 'var':
            argtempvars = []
            for arg in self.args:
                argtype, argtempvar = arg.translate(ctx)
                if argtype == 'void':
                    raise Error(
                        [arg.token],
                        'void expression cannot be used as an argument')
                argtempvar = ctx.varify(argtype, argtempvar)
                argtempvars.append(argtempvar)
            tempvar = ctx.mktemp('var')
            nargs = len(self.args)
            temparr = ctx.mktemparr(nargs)
            cfname = ctx.cname(defn.name)
            for i, argtempvar in enumerate(argtempvars):
                ctx.src += f'{temparr}[{i}] = {argtempvar};'
            ctx.src += f'{tempvar} = KLC_var_call({cfname}, {nargs}, {temparr});'
            return ('var', tempvar)

        raise Error([self.token, defn.token],
                    f'{self.function} is not a function')


class VariableDefinition(Statement, BaseVariableDefinition):
    fields = BaseVariableDefinition.fields + (
        ('expression', Optional[Expression]),
    )

    def translate(self, ctx):
        ctx.scope.add(self)
        if self.expression:
            ectx = ctx.ectx()
            etype, tempvar = self.expression.translate(ectx)
            value = tempvar
            if self.type == 'var' and etype != 'void':
                value = ctx.varify(etype, tempvar)
            elif self.type != etype:
                raise Error([self.token],
                            f'Expected {self.type} but got {etype}')
            ectx.src += f'{self.cname(ectx)} = {value};'
            ectx.release_tempvars(tempvar)


class ExpressionStatement(Statement):
    fields = (
        ('expression', Optional[Expression]),
    )

    def translate(self, ctx):
        ectx = ctx.ectx()
        self.expression.translate(ectx)
        ectx.release_tempvars()


class Return(Statement):
    fields = (
        ('expression', Optional[Expression]),
    )

    def translate(self, ctx):
        ectx = ctx.ectx()
        if self.expression:
            rtype, tempvar = self.expression.translate(ectx)
        else:
            rtype = 'void'
        fctx = ctx.fctx
        expected_rtype = fctx.fdef.return_type
        if expected_rtype != rtype:
            raise Error([fctx.fdef.token, self.token],
                        f'Function was declared to return {expected_rtype} '
                        f'but tried to return {rtype} instead')
        if rtype == 'void':
            _release_for_return(ctx, ectx.src)
            ectx.src += 'return;'
        else:
            ectx.release_tempvars(tempvar)
            _release_for_return(ctx, ectx.src)
            ectx.src += f'return {tempvar};'

        return True


def _release_for_return(ctx, src):
    # Before returning, we should release all local variables
    # We need to take care not to release function parameters
    # or global variables
    scope = ctx.scope
    while scope:
        for vdef in reversed(scope.local_definitions):
            if isinstance(vdef, VariableDefinition):
                src += vdef.crelease(ctx)
        scope = scope.parent


class Block(Statement):
    fields = (
        ('statements', List[Statement]),
    )

    def translate(self, pctx):
        pctx.src += '{'
        prologue = pctx.src.spawn(1)
        ctx = pctx.bctx(1)
        epilogue = pctx.src.spawn(1)
        pctx.src += '}'
        early_return = False
        for i, statement in enumerate(self.statements):
            if statement.translate(ctx):
                early_return = True
                if i + 1 < len(self.statements):
                    raise Error([self.statements[i + 1].token],
                                'Unreachable statement')
                break

        # Declare the local variables for C
        # To be C89 compatible, we need all variable definitions
        # to appear at the beginning of the block.
        for vdef in ctx.scope.local_definitions:
            assert isinstance(vdef, VariableDefinition), vdef
            prologue += f'{vdef.cproto(ctx)} = {ctx.czero(vdef.type)};'

        # If there's an early return, there's no need to have an
        # epilogue and generate unreachable code.
        if not early_return:
            # If we don't have an early return, we should
            # make sure to release all local variables defined in
            # this block before exiting
            # We should also release in LIFO order
            for vdef in reversed(ctx.scope.local_definitions):
                if vdef.type not in PRIMITIVE_TYPES:
                    epilogue += vdef.crelease(ctx)


class GlobalTranslationContext(TranslationContext):
    def __init__(self, program):
        super().__init__(Scope(None))
        for d in program.definitions:
            self.scope.add(d)
        self.out = FractalStringBuilder(0)
        self.out(PRELUDE)
        self.fwd = self.out.spawn()
        self.hdr = self.out.spawn()
        self.src = self.out.spawn()

    def fctx(self, fdef):
        "Create child function translation context"
        return FunctionTranslationContext(self, fdef)


class BodyTranslationContext(TranslationContext):

    def bctx(self, depth):
        return BlockTranslationContext(self, depth)


class FunctionTranslationContext(BodyTranslationContext):
    def __init__(self, gctx, fdef):
        super().__init__(Scope(gctx.scope))
        for param in fdef.params:
            self.scope.add(param)
        self.parent = gctx
        self.fdef = fdef
        self.hdr = gctx.hdr.spawn()
        self.src = gctx.src.spawn()
        self.fctx = self


class BlockTranslationContext(BodyTranslationContext):
    def __init__(self, parent: BodyTranslationContext, depth):
        super().__init__(Scope(parent.scope))
        self.parent = parent
        self.fctx = parent.fctx
        self.src = parent.src.spawn(depth)

    def ectx(self):
        return ExpressionTranslationContext(self)


class ExpressionTranslationContext(TranslationContext):
    def __init__(self, parent: BlockTranslationContext):
        super().__init__(parent.scope)
        self.parent = parent
        self.tempdecls = []  # (type, cname) pairs of temporary vars
        parent.src += '{'
        self.tmp = parent.src.spawn(1)
        self.src = parent.src.spawn(1)
        parent.src += '}'
        self.next_tempvar_index = 0

    def _next_tempvar_name(self):
        i = self.next_tempvar_index
        self.next_tempvar_index += 1
        return f'tempvar{i}'

    def mktemp(self, type_):
        tempvar = self._next_tempvar_name()
        self.tempdecls.append((type_, tempvar))
        self.tmp += f'{self.cdecltype(type_)} {tempvar} = {self.czero(type_)};'
        return tempvar

    def mktemparr(self, n):
        tempvar = self._next_tempvar_name()
        self.tmp += f'KLC_var {tempvar}[{n}];'
        return tempvar

    def release_tempvars(self, keepvar=None):
        """Release all temporary variables used during expression
        evaluation, except the specified keepvar.
        Variables are released in LIFO order
        """
        for type_, cname in reversed(self.tempdecls):
            if cname != keepvar:
                self.src += _crelease(self, type_, cname)


class Program(Node):
    fields = (
        ('definitions', List[GlobalDefinition]),
    )

    def translate(self):
        ctx = GlobalTranslationContext(self)
        for d in self.definitions:
            d.translate(ctx)
        return str(ctx.out)


class FunctionDefinition(GlobalDefinition):
    fields = (
        ('return_type', str),
        ('name', str),
        ('params', List[Parameter]),
        ('body', Optional[Block]),
    )

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if self.name == 'main':
            if self.return_type != 'void' or len(self.params):
                raise Error([self.token],
                            'main function must have signature '
                            "'void main()'")

    @property
    def extern(self):
        return self.body is None

    def cproto(self, ctx):
        crt = ctx.cdecltype(self.return_type)
        cname = ctx.cname(self.name)
        cparams = ', '.join(p.cproto(ctx) for p in self.params)
        return f'{crt} {cname}({cparams})'

    def untyped_cproto(self, ctx):
        return f'KLC_var KLC_untyped{self.name}(int argc, KLC_var* argv)'

    def translate(self, gctx: GlobalTranslationContext):
        ctx = gctx.fctx(self)

        self._translate_untyped(ctx)

        ctx.hdr += self.cproto(ctx) + ';'
        if self.body:
            ctx.src += self.cproto(ctx)
            self.body.translate(ctx)

    def _translate_untyped(self, ctx):
        ctx.hdr += self.untyped_cproto(ctx) + ';'
        ctx.src += self.untyped_cproto(ctx) + '{'
        src = ctx.src.spawn(1)
        ctx.src += '}'
        for i, param in enumerate(self.params):
            src += f'{ctx.cdecltype(param.type)} arg{i};'
        src += f'if (argc != {len(self.params)}) ' '{'
        src += f'  KLC_errorf("Function \'%s\' expected %d args but got %d", \"{self.name}\", {len(self.params)}, argc);'
        src += '}'
        for i, param in enumerate(self.params):
            src += f'arg{i} = {ctx.unvarify(param.type, f"argv[{i}]")};'
        argsstr = ', '.join(f'arg{i}' for i in range(len(self.params)))
        call = f'{ctx.cname(self.name)}({argsstr})'
        if self.return_type == 'void':
            src += f'{call};'
            src += 'return KLC_zero;'
        else:
            src += f'return {ctx.varify(self.return_type, call)};'



class TypeDefinition(GlobalDefinition):
    pass


class ClassDefinition(TypeDefinition):
    fields = (
        ('name', str),
        ('fields', Optional[List[Field]]),
    )

    @property
    def extern(self):
        return self.fields is None

    def translate(self, ctx: GlobalTranslationContext):
        name = self.name
        cname = ctx.cname(name)
        cdecltype = ctx.cdecltype(name)

        del_name = f'KLC_delete{name}'
        malloc_name = f'KLC_malloc{name}'

        delete_proto = f'void {del_name}(KLC_header* robj, KLC_header** dq)'
        malloc_proto = f'{cdecltype} {malloc_name}()'

        ctx.hdr += delete_proto + ';'
        ctx.hdr += malloc_proto + ';'

        if self.extern:
            return

        ctx.fwd += f'typedef struct {cname} {cname};'

        ctx.hdr += f'struct {cname} ' '{'
        ctx.hdr += '  KLC_header header;'
        for field in self.fields:
            ctx.hdr += f'  {field.cproto(ctx)};'
        ctx.hdr += '};'

        ctx.src += f'KLC_typeinfo KLC_type{name} = ' '{'
        ctx.src += f'  "{name}",'
        ctx.src += f'  &{del_name}'
        ctx.src += '};'

        ctx.src += delete_proto + '{'
        objfields = [f for f in self.fields if f.type not in PRIMITIVE_TYPES]
        if objfields:
            ctx.src += f'  {cdecltype} obj = ({cdecltype}) robj;'
            for field in objfields:
                cfname = ctx.cname(field.name)
                if field.type == 'var':
                    ctx.src += f'  KLC_partial_release_var(obj->{cfname}, dq);'
                else:
                    ctx.src += f'  KLC_partial_release((KLC_header*) obj->{cfname}, dq);'
        ctx.src += '}'

        ctx.src += malloc_proto + '{'
        ctx.src += f'  {cdecltype} obj = ({cdecltype}) malloc(sizeof({cname}));'
        for field in self.fields:
            cfname = ctx.cname(field.name)
            ctx.src += f'  obj->{cfname} = {ctx.czero(field.type)};'
        ctx.src += '  return obj;'
        ctx.src += '}'


tok = lex(Source('<dummy>', 'dummy'))[0]

node = Program(tok, [
    ClassDefinition(tok, 'String', None),
    ClassDefinition(tok, 'Foo', [
        Field(tok, 'var', 'v'),
        Field(tok, 'int', 'i'),
        Field(tok, 'String', 's'),
    ]),
    FunctionDefinition(tok, 'void', 'foo', [Parameter(tok, 'var', 'callback')], Block(tok, [
        ExpressionStatement(tok, FunctionCall(tok, 'callback', [StringLiteral(tok, 'hi')])),
    ])),
    FunctionDefinition(tok, 'void', 'puts', [Parameter(tok, 'String', 'x')], None),
    FunctionDefinition(tok, 'String', 'id', [Parameter(tok, 'String', 'x')], Block(tok, [
        Return(tok, StringLiteral(tok, 'id-result')),
    ])),
    FunctionDefinition(tok, 'void', 'main', [], Block(tok, [
        ExpressionStatement(tok, FunctionCall(
            tok, 'puts', [StringLiteral(tok, 'Hello world!')]
        )),
        VariableDefinition(tok, "String", "s", StringLiteral(tok, "Hello world2")),
        VariableDefinition(tok, "var", "v", StringLiteral(tok, "Hello world2")),
        ExpressionStatement(tok, FunctionCall(tok, 'puts', [Name(tok, 's')])),
        ExpressionStatement(tok, FunctionCall(tok, 'puts', [
            FunctionCall(tok, 'id', [StringLiteral(tok, 'id-arg')]),
        ])),
        ExpressionStatement(tok, FunctionCall(tok, 'foo', [Name(tok, 'puts')])),
    ])),
])

print(node.translate())


# print(lex(Source('<string>', 'abc + def')))
# print(translate(Source('<string>', """
# class String;
# class List;
#
# class Foo {
#   size_t i;
#   int x;
# }
#
# class Bar {
#   Foo foo;
# }
#
# void puts(String s);
# String sprintf(String fmt, List args);
#
# void main() {}
#
# """)))
