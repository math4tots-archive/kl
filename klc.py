"""KL Compiler

python3 klc.py > main.c && \
gcc -Wall -Werror -Wpedantic -Wno-unused-function --std=c89 main.c && \
./a.out && \
rm a.out main.c
"""
import sys


C_PREFIX = r"""/* Autogenerated by KLC */
#include <stdio.h>
#include <stdlib.h>

#define KLC_OK 0
#define KLC_ERROR 1

typedef int KLC_Status;
typedef struct KLC_header KLC_header;
typedef struct KLC_typeinfo KLC_typeinfo;
typedef struct KLCN_String KLCN_String;

struct KLC_header {
    KLC_typeinfo *ti;
    KLC_header *next;
    size_t refcnt;
};

struct KLC_typeinfo {
    const char *name;
    void (*deleter)(KLC_header*);
};

struct KLCN_String {
    KLC_typeinfo ti;
    size_t size;
    const char *buffer;
};

static KLC_header *delete_queue = NULL;

static void KLC_retain(KLC_header *obj) {
    obj->refcnt++;
}

static void KLC_release_nonrecursive(KLC_header *obj) {
    if (obj->refcnt <= 1) {
        obj->next = delete_queue;
        delete_queue = obj;
    } else {
        obj->refcnt--;
    }
}

static void KLC_release(KLC_header *obj) {
    KLC_release_nonrecursive(obj);
    while (delete_queue) {
        obj = delete_queue;
        obj->ti->deleter(obj);
        delete_queue = delete_queue->next;
    }
}

static KLC_Status KLC_print(KLC_header **out, KLCN_String *s) {
    printf("%s\n", s->buffer);
    return KLC_OK;
}

extern KLC_Status KLCN_main();

int main() {
    if (KLCN_main() != KLC_OK) {
        fprintf(stderr, "ERROR...\n");
        return 1;
    }
    return 0;
}
"""


primitive_types = {
    'void',
    'int',
    'double',
}


class FakeType(object):
    @property
    def __name__(self):
        return repr(self)


class StringBuilder(FakeType):
    def __init__(self):
        self.parts = []

    def __str__(self):
        self.parts = [''.join(self.parts)]
        return self.parts[0]

    def __iadd__(self, part):
        self.parts.append(part)
        return self


class ListType(FakeType):
    def __init__(self, subtype):
        self.subtype = subtype

    def __getitem__(self, subtype):
        return ListType(subtype)

    def __instancecheck__(self, obj):
        return (
            isinstance(obj, list) and
            all(isinstance(x, self.subtype) for x in obj))

    def __repr__(self):
        return 'List[%s]' % (self.subtype.__name__, )


List = ListType(object)


class OptionalType(object):
    def __init__(self, subtype):
        self.subtype = subtype

    def __getitem__(self, subtype):
        return OptionalType(subtype)

    def __instancecheck__(self, obj):
        return obj is None or isinstance(obj, self.subtype)

    def __repr__(self):
        return 'Optional[%s]' % (self.subtype.__name__, )


Optional = OptionalType(object)


def _ctype(typename):
    if typename in primitive_types:
        return typename
    else:
        return _cname(typename) + '*'


def _cname(name):
    return 'KLCN_' + name


class Node(object):
    def __init__(self, token, *args):
        self.token = token
        for (fname, ftype), arg in zip(type(self).fields, args):
            # sys.stderr.write('ftype = %r\n' % (ftype, ))
            if not isinstance(arg, ftype):
                raise TypeError('Expected type of %r to be %r, but got %r' % (
                    fname, ftype, arg))
            setattr(self, fname, arg)
        if len(type(self).fields) != len(args):
            raise TypeError('%s expects %s arguments, but got %s' % (
                type(self).__name__, len(type(self).fields), len(args)))

    def __repr__(self):
        return '%s(%s)' % (
            type(self).__name__,
            ', '.join(repr(getattr(self, n)) for n, _ in type(self).fields),
        )


class TopLevelNode(Node):
    pass


class Statement(Node):
    pass


class Expression(Node):
    pass


class Program(Node):
    fields = (
        ('nodes', List[TopLevelNode]),
    )

    def create_scope(self):
        scope = dict()
        for node in self.nodes:
            if node.name in scope:
                raise TypeError('Name %r declared more than once' % (
                    node.name,
                ))
            scope[node.name] = node
        return scope

    def translate(self):
        scope = self.create_scope()
        fwd = StringBuilder()
        hdr = StringBuilder()
        src = StringBuilder()
        for node in self.nodes:
            node.translate(scope, fwd, hdr, src)
        return '%s%s%s%s' % (C_PREFIX, fwd, hdr, src)


class VariableDeclaration(Node):
    fields = (
        ('type', str),
        ('name', str),
    )

    @property
    def proto(self):
        return '%s %s' % (_ctype(self.type), _cname(self.name))

    def translate(self, scope, src, depth):
        src += '  ' * depth + self.proto + ' = '
        if self.type in primitive_types:
            src += '0'
        else:
            src += 'NULL'
        src += ';\n'


class Block(Statement):
    fields = (
        ('variables', List[VariableDeclaration]),
        ('statements', List[Statement]),
    )

    def translate(self, parent_scope, src, depth):
        src += '  ' * depth + '{\n'
        scope = dict(parent_scope)
        for d in self.variables:
            # This is necessary to ensure that releases are done properly
            if any(loc.name == d.name for loc in scope['@locals']):
                raise TypeError('Shadowed local variable %r' % (d.name, ))
            scope['@locals'].append(d)
            scope[d.name] = d
            d.translate(scope, src, depth + 1)

        for statement in self.statements:
            statement.translate(scope, src, depth + 1)

        for d in reversed(self.variables):
            assert d is scope['@locals'].pop()
            if d.type not in primitive_types:
                src += '  ' * (depth + 1) + 'KLC_release()'

        src += '  ' * depth + '}\n'


class FunctionDefinition(TopLevelNode):
    fields = (
        ('return_type', str),
        ('name', str),
        ('params', List[VariableDeclaration]),
        ('body', Optional[Block]),
    )

    @property
    def extern(self):
        return self.body is None

    @property
    def cparams(self):
        inputs = ', '.join(d.proto for d in self.params)
        if self.return_type is 'void':
            return inputs
        else:
            return _ctype(self.return_type) + '* out, ' + inputs

    @property
    def proto(self):
        return 'KLC_Status %s(%s)' % (
            _cname(self.name),
            self.cparams,
        )

    def translate(self, parent_scope, fwd, hdr, src):
        scope = dict(parent_scope)
        for param in self.params:
            scope[param.name] = param
        scope['@locals'] = []
        hdr += self.proto + ';\n'
        if self.body is not None:
            src += self.proto + '{\n'
            self.body.translate(scope, src, 1)
            src += '  return KLC_OK;\n'
            src += '}\n'


print(Program(
    None,
    [
        FunctionDefinition(
            None, 'void', 'main', [],
            Block(
                None,
                [
                    VariableDeclaration(None, 'int', 'x'),
                ],
                [
                ],
            )
        )
    ],
).translate())

