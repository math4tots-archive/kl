/* Autogenerated by the KL Compiler */
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define KLC_TAG_INT 0
#define KLC_TAG_LONG 1
#define KLC_TAG_SIZE_T 2
#define KLC_TAG_DOUBLE 3
#define KLC_TAG_FUNCTION 4
#define KLC_TAG_OBJECT 5

typedef struct KLC_header KLC_header;
typedef struct KLC_typeinfo KLC_typeinfo;
typedef struct KLC_var KLC_var;
typedef KLC_var (*KLC_Function)(int, KLC_var*);

struct KLC_header {
  KLC_typeinfo* type;
  size_t refcnt;
  KLC_header* next;
};

struct KLC_typeinfo {
  const char* name;
  void (*deleter)(KLC_header*, KLC_header**);
};

struct KLC_var {
  int tag;
  union {
    KLC_header* obj;
    int i;
    long l;
    size_t s;
    double d;
    KLC_Function f;
  } u;
};

void KLC_errorf(const char* fmt, ...) {
  int* i = NULL;
  va_list args;
  va_start(args, fmt);
  vfprintf(stderr, fmt, args);
  va_end(args);
  printf("%d\n", *i);
}

void KLC_retain(KLC_header *obj) {
  if (obj) {
    obj->refcnt++;
  }
}

void KLC_retain_var(KLC_var v) {
  if (v.tag == KLC_TAG_OBJECT) {
    KLC_retain(v.u.obj);
  }
}

void KLC_partial_release(KLC_header* obj, KLC_header** delete_queue) {
  if (obj) {
    if (obj->refcnt) {
      obj->refcnt--;
    } else {
      obj->next = *delete_queue;
      *delete_queue = obj;
    }
  }
}

void KLC_partial_release_var(KLC_var v, KLC_header** delete_queue) {
  if (v.tag == KLC_TAG_OBJECT) {
    KLC_partial_release(v.u.obj, delete_queue);
  }
}

void KLC_release(KLC_header *obj) {
  KLC_header* delete_queue = NULL;
  KLC_partial_release(obj, &delete_queue);
  while (delete_queue) {
    obj = delete_queue;
    delete_queue = delete_queue->next;
    obj->type->deleter(obj, &delete_queue);
    free(obj);
  }
}

void KLC_release_var(KLC_var v) {
  if (v.tag == KLC_TAG_OBJECT) {
    KLC_release(v.u.obj);
  }
}

KLC_var KLC_int_to_var(int i) {
  KLC_var ret;
  ret.tag = KLC_TAG_INT;
  ret.u.i = i;
  return ret;
}

KLC_var KLC_long_to_var(long l) {
  KLC_var ret;
  ret.tag = KLC_TAG_LONG;
  ret.u.l = l;
  return ret;
}

KLC_var KLC_size_t_to_var(size_t s) {
  KLC_var ret;
  ret.tag = KLC_TAG_SIZE_T;
  ret.u.s = s;
  return ret;
}

KLC_var KLC_double_to_var(double d) {
  KLC_var ret;
  ret.tag = KLC_TAG_DOUBLE;
  ret.u.d = d;
  return ret;
}

KLC_var KLC_function_to_var(KLC_Function f) {
  KLC_var ret;
  ret.tag = KLC_TAG_FUNCTION;
  ret.u.f = f;
  return ret;
}

KLC_var KLC_object_to_var(KLC_header* obj) {
  KLC_var ret;
  ret.tag = KLC_TAG_OBJECT;
  ret.u.obj = obj;
  return ret;
}

KLC_header* KLC_var_to_object(KLC_var v, KLC_typeinfo* ti) {
  /* TODO: Better error message */
  KLC_header* ret;
  if (v.tag != KLC_TAG_OBJECT) {
    KLC_errorf("var_to_object: not an object\n");
  }
  if (ti != v.u.obj->type) {
    KLC_errorf("var_to_object: not the right object type\n");
  }
  return v.u.obj;
}

KLC_var KLC_var_call(KLC_var f, int argc, KLC_var* argv) {
  /* TODO: Better error message */
  KLC_var result;

  if (f.tag != KLC_TAG_FUNCTION) {
    KLC_errorf("Not a function\n");
  }

  result = f.u.f(argc, argv);

  return result;
}

typedef struct KLCNString KLCNString;
struct KLCNString {
  KLC_header header;
  size_t size;
  char *buffer;
};

void KLC_deleteString(KLC_header* robj, KLC_header** dq) {
  KLCNString *obj = (KLCNString*) robj;
  free(obj->buffer);
}

KLC_typeinfo KLC_typeString = {
  "String",
  KLC_deleteString
};

KLCNString* KLC_mkstr(const char *str) {
  KLCNString* obj = (KLCNString*) malloc(sizeof(KLCNString));
  size_t len = strlen(str);
  char* buffer = (char*) malloc(sizeof(char) * (len + 1));
  strcpy(buffer, str);
  obj->header.type = &KLC_typeString;
  obj->header.refcnt = 0;
  obj->header.next = NULL;
  obj->size = len;
  obj->buffer = buffer;
  return obj;
}

void KLCNputs(KLCNString *s) {
  printf("%s\n", s->buffer);
}

void KLCNmain();

static KLC_var KLC_zero = {
  KLC_TAG_OBJECT,
  { NULL }
};

int main() {
  KLCNmain();
  return 0;
}

typedef struct KLCNFoo KLCNFoo;
void KLC_deleteString(KLC_header* robj, KLC_header** dq);
KLCNString* KLC_mallocString();
void KLC_deleteFoo(KLC_header* robj, KLC_header** dq);
KLCNFoo* KLC_mallocFoo();
struct KLCNFoo {
  KLC_header header;
  KLC_var KLCNv;
  int KLCNi;
  KLCNString* KLCNs;
};
KLC_var KLC_untypedfoo(int argc, KLC_var* argv);
void KLCNfoo(KLC_var KLCNcallback);
KLC_var KLC_untypedputs(int argc, KLC_var* argv);
void KLCNputs(KLCNString* KLCNx);
KLC_var KLC_untypedid(int argc, KLC_var* argv);
KLCNString* KLCNid(KLCNString* KLCNx);
KLC_var KLC_untypedmain(int argc, KLC_var* argv);
void KLCNmain();
KLC_typeinfo KLC_typeFoo = {
  "Foo",
  &KLC_deleteFoo
};
void KLC_deleteFoo(KLC_header* robj, KLC_header** dq){
  KLCNFoo* obj = (KLCNFoo*) robj;
  KLC_partial_release_var(obj->KLCNv, dq);
  KLC_partial_release((KLC_header*) obj->KLCNs, dq);
}
KLCNFoo* KLC_mallocFoo(){
  KLCNFoo* obj = (KLCNFoo*) malloc(sizeof(KLCNFoo));
  obj->KLCNv = KLC_zero;
  obj->KLCNi = 0;
  obj->KLCNs = NULL;
  return obj;
}
KLC_var KLC_untypedfoo(int argc, KLC_var* argv){
  KLC_var arg0;
  if (argc != 1) {
    KLC_errorf("Function '%s' expected %d args but got %d", "foo", 1, argc);
  }
  arg0 = argv[0];
  KLCNfoo(arg0);
  return KLC_zero;
}
void KLCNfoo(KLC_var KLCNcallback)
{
  {
    KLCNString* tempvar0 = NULL;
    KLC_var tempvar1 = KLC_zero;
    KLC_var tempvar2[1];
    tempvar0 = KLC_mkstr("hi");
    tempvar2[0] = KLC_object_to_var((KLC_header*) tempvar0);
    tempvar1 = KLC_var_call(KLCNcallback, 1, tempvar2);
    KLC_release_var(tempvar1);
    KLC_release((KLC_header*) tempvar0);
  }
}
KLC_var KLC_untypedputs(int argc, KLC_var* argv){
  KLCNString* arg0;
  if (argc != 1) {
    KLC_errorf("Function '%s' expected %d args but got %d", "puts", 1, argc);
  }
  arg0 = (KLCNString*) KLC_var_to_object(argv[0], &KLC_typeString);
  KLCNputs(arg0);
  return KLC_zero;
}
KLC_var KLC_untypedid(int argc, KLC_var* argv){
  KLCNString* arg0;
  if (argc != 1) {
    KLC_errorf("Function '%s' expected %d args but got %d", "id", 1, argc);
  }
  arg0 = (KLCNString*) KLC_var_to_object(argv[0], &KLC_typeString);
  return KLC_object_to_var((KLC_header*) KLCNid(arg0));
}
KLCNString* KLCNid(KLCNString* KLCNx)
{
  {
    KLCNString* tempvar0 = NULL;
    tempvar0 = KLC_mkstr("id-result");
    return tempvar0;
  }
}
KLC_var KLC_untypedmain(int argc, KLC_var* argv){
  if (argc != 0) {
    KLC_errorf("Function '%s' expected %d args but got %d", "main", 0, argc);
  }
  KLCNmain();
  return KLC_zero;
}
void KLCNmain()
{
  KLCNString* KLCNs = NULL;
  KLC_var KLCNv = KLC_zero;
  {
    KLCNString* tempvar0 = NULL;
    tempvar0 = KLC_mkstr("Hello world!");
    KLCNputs(tempvar0);
    KLC_release((KLC_header*) tempvar0);
  }
  {
    KLCNString* tempvar0 = NULL;
    tempvar0 = KLC_mkstr("Hello world2");
    KLCNs = tempvar0;
  }
  {
    KLCNString* tempvar0 = NULL;
    tempvar0 = KLC_mkstr("Hello world2");
    KLCNv = KLC_object_to_var((KLC_header*) tempvar0);
  }
  {
    KLCNString* tempvar0 = NULL;
    tempvar0 = KLCNs;
    KLC_retain((KLC_header*) tempvar0);
    KLCNputs(tempvar0);
    KLC_release((KLC_header*) tempvar0);
  }
  {
    KLCNString* tempvar0 = NULL;
    KLCNString* tempvar1 = NULL;
    tempvar0 = KLC_mkstr("id-arg");
    tempvar1 = KLCNid(tempvar0);
    KLCNputs(tempvar1);
    KLC_release((KLC_header*) tempvar1);
    KLC_release((KLC_header*) tempvar0);
  }
  {
    KLC_var tempvar0 = KLC_zero;
    tempvar0 = KLC_function_to_var(KLC_untypedputs);
    KLCNfoo(tempvar0);
    KLC_release_var(tempvar0);
  }
  KLC_release_var(KLCNv);
  KLC_release((KLC_header*) KLCNs);
}

